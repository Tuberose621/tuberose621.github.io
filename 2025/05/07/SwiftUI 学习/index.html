<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SwiftUI 学习 | 技术成长笔记</title><meta name="author" content="葛聪颖"><meta name="copyright" content="葛聪颖"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、为什么 SwiftUI 中的视图用 struct 而不是 class 值类型设计：SwiftUI 采用声明式编程，视图本身被设计成值类型（struct）。每次状态变化时，系统会重新创建视图（“刷新”视图），这种方式可以更高效地进行视图更新和比对，从而实现差异化渲染。 不可变性与安全性：struct 是不可变的，减少了多线程和状态管理中的复杂性，使得数据流更清晰。用 struct 定义视图可以保">
<meta property="og:type" content="article">
<meta property="og:title" content="SwiftUI 学习">
<meta property="og:url" content="https://tuberose621.github.io/2025/05/07/SwiftUI%20%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="技术成长笔记">
<meta property="og:description" content="一、为什么 SwiftUI 中的视图用 struct 而不是 class 值类型设计：SwiftUI 采用声明式编程，视图本身被设计成值类型（struct）。每次状态变化时，系统会重新创建视图（“刷新”视图），这种方式可以更高效地进行视图更新和比对，从而实现差异化渲染。 不可变性与安全性：struct 是不可变的，减少了多线程和状态管理中的复杂性，使得数据流更清晰。用 struct 定义视图可以保">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tuberose621.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-05-07T10:05:15.000Z">
<meta property="article:modified_time" content="2025-06-07T08:33:34.209Z">
<meta property="article:author" content="葛聪颖">
<meta property="article:tag" content="SwiftUI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tuberose621.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SwiftUI 学习",
  "url": "https://tuberose621.github.io/2025/05/07/SwiftUI%20%E5%AD%A6%E4%B9%A0/",
  "image": "https://tuberose621.github.io/img/butterfly-icon.png",
  "datePublished": "2025-05-07T10:05:15.000Z",
  "dateModified": "2025-06-07T08:33:34.209Z",
  "author": [
    {
      "@type": "Person",
      "name": "葛聪颖",
      "url": "https://tuberose621.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tuberose621.github.io/2025/05/07/SwiftUI%20%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SwiftUI 学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta http-equiv="Pragma" content="no-cache" /><meta http-equiv="Expires" content="0" /><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">技术成长笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">SwiftUI 学习</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">SwiftUI 学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-07T10:05:15.000Z" title="发表于 2025-05-07 18:05:15">2025-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-07T08:33:34.209Z" title="更新于 2025-06-07 16:33:34">2025-06-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="一、为什么-SwiftUI-中的视图用-struct-而不是-class"><a href="#一、为什么-SwiftUI-中的视图用-struct-而不是-class" class="headerlink" title="一、为什么 SwiftUI 中的视图用 struct 而不是 class"></a>一、为什么 SwiftUI 中的视图用 struct 而不是 class</h3><ul>
<li><strong>值类型设计</strong>：<code>SwiftUI</code> 采用声明式编程，视图本身被设计成值类型（<code>struct</code>）。每次状态变化时，系统会重新创建视图（“刷新”视图），这种方式可以更高效地进行视图更新和比对，从而实现差异化渲染。</li>
<li><strong>不可变性与安全性</strong>：<code>struct</code> 是不可变的，减少了多线程和状态管理中的复杂性，使得数据流更清晰。用 <code>struct</code> 定义视图可以保证不小心修改视图结构带来的副作用更少。</li>
<li><strong>轻量与性能优化</strong>：视图通常很轻量，<code>struct</code> 类型在内存分配和拷贝上更高效。<code>SwiftUI</code> 利用这种值类型的特性，对界面变化做高效计算和 <code>diff</code> 运算。</li>
</ul>
<p>因此，在 <code>SwiftUI</code> 中，大部分视图都是以 <code>struct</code> 来定义，而不是使用 <code>class</code>。</p>
<hr>
<hr>
<h3 id="二、声明式编程"><a href="#二、声明式编程" class="headerlink" title="二、声明式编程"></a>二、声明式编程</h3><p><code>SwiftUI</code> 就是声明式编程（<code>Declarative Programming</code>）的一种典型体现。先解释概念，再具体说 <code>SwiftUI</code> 的实践方式。</p>
<hr>
<h4 id="一、什么是声明式编程？"><a href="#一、什么是声明式编程？" class="headerlink" title="一、什么是声明式编程？"></a>一、什么是声明式编程？</h4><p>🧠 定义：</p>
<blockquote>
<p>声明式编程是一种编程范式，<strong>你只需要描述“做什么”而不是“怎么做”</strong>。</p>
</blockquote>
<p>相比之下，<code>命令式编程（Imperative Programming</code>是逐条告诉计算机“怎么一步步做”。</p>
<hr>
<h4 id="🔍-举个简单例子（iOS-编程场景）："><a href="#🔍-举个简单例子（iOS-编程场景）：" class="headerlink" title="🔍 举个简单例子（iOS 编程场景）："></a>🔍 举个简单例子（iOS 编程场景）：</h4><h4 id="命令式（UIKit）："><a href="#命令式（UIKit）：" class="headerlink" title="命令式（UIKit）："></a>命令式（UIKit）：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">label.text <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">label.textColor <span class="operator">=</span> .red</span><br><span class="line">view.addSubview(label)</span><br></pre></td></tr></table></figure>

<p>你要一步步地“创建 → 配置 → 加到视图上”。</p>
<hr>
<h4 id="声明式（SwiftUI）："><a href="#声明式（SwiftUI）：" class="headerlink" title="声明式（SwiftUI）："></a>声明式（SwiftUI）：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .foregroundColor(.red)</span><br></pre></td></tr></table></figure>

<p>你只“声明”了这个视图长什么样，系统会<strong>根据状态自动渲染</strong>出来。</p>
<hr>
<h4 id="二、声明式编程的核心特点"><a href="#二、声明式编程的核心特点" class="headerlink" title="二、声明式编程的核心特点"></a>二、声明式编程的核心特点</h4><table>
<thead>
<tr>
<th>特征</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>状态驱动</td>
<td>UI 与数据状态绑定，状态变 → UI自动更新</td>
</tr>
<tr>
<td>不可变结构</td>
<td>用值类型（如 struct）描述 UI，不直接修改视图</td>
</tr>
<tr>
<td>关注“结果”</td>
<td>你描述“要显示的内容”，不关心渲染细节</td>
</tr>
<tr>
<td>更适合组合</td>
<td>视图嵌套&#x2F;组合方式更清晰（如 VStack&#x2F;HStack）</td>
</tr>
</tbody></table>
<hr>
<h4 id="三、SwiftUI-是怎么体现声明式编程的？"><a href="#三、SwiftUI-是怎么体现声明式编程的？" class="headerlink" title="三、SwiftUI 是怎么体现声明式编程的？"></a>三、SwiftUI 是怎么体现声明式编程的？</h4><ol>
<li><p><strong>UI &#x3D; 状态的函数</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Add&quot;</span>) &#123;</span><br><span class="line">        count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉 SwiftUI 监听 <code>@State</code> 的变化，自动重建视图。你只描述“UI 在什么状态下应该呈现什么样”。</p>
</li>
<li><p><strong>结构即视图</strong><br>所有 <code>View</code> 都是 <code>struct</code>，没有复杂的生命周期管理（不像 <code>UIKit</code> 中有 <code>viewDidLoad</code>、<code>viewWillAppear</code> 等）。</p>
</li>
<li><p><strong>自动Diff &amp; 渲染</strong><br>你不需要手动调用 <code>reloadData()</code> 或 <code>setNeedsLayout()</code>，状态一变 <code>UI</code> 自动刷新。</p>
</li>
</ol>
<hr>
<h4 id="四、总结：SwiftUI-vs-UIKit-编程范式"><a href="#四、总结：SwiftUI-vs-UIKit-编程范式" class="headerlink" title="四、总结：SwiftUI vs UIKit 编程范式"></a>四、总结：SwiftUI vs UIKit 编程范式</h4><table>
<thead>
<tr>
<th>对比点</th>
<th>UIKit（命令式）</th>
<th>SwiftUI（声明式）</th>
</tr>
</thead>
<tbody><tr>
<td>UI 描述方式</td>
<td>一步步设置组件属性</td>
<td>直接声明组件内容和样式</td>
</tr>
<tr>
<td>数据绑定</td>
<td>手动管理</td>
<td>自动状态绑定（@State、@Binding）</td>
</tr>
<tr>
<td>响应更新</td>
<td>需要手动刷新</td>
<td>数据变动 → UI自动刷新</td>
</tr>
<tr>
<td>易错性</td>
<td>状态管理繁琐，易出 bug</td>
<td>更简洁、安全、自动化</td>
</tr>
</tbody></table>
<hr>
<h4 id="五、现实启示"><a href="#五、现实启示" class="headerlink" title="五、现实启示"></a>五、现实启示</h4><p><code>SwiftUI</code> 的声明式模式适合构建<strong>状态驱动的 UI</strong>、<strong>响应式交互</strong>，逻辑更清晰，特别适合复杂视图组合、动画、实时响应。</p>
<hr>
<hr>
<h3 id="三、SwiftUI-状态管理-数据绑定：全面解析"><a href="#三、SwiftUI-状态管理-数据绑定：全面解析" class="headerlink" title="三、SwiftUI 状态管理 &amp; 数据绑定：全面解析"></a>三、SwiftUI 状态管理 &amp; 数据绑定：全面解析</h3><p>SwiftUI 提供了一套<strong>响应式数据绑定机制</strong>，其中包括 <code>@State</code>、<code>@Binding</code>、<code>@Environment</code>、<code>@ObservableObject</code> 等属性包装器。要正确使用它们，首先要理解它们的用途、联系以及适用场景。</p>
<hr>
<h4 id="📌-SwiftUI-的状态管理-数据绑定关键概念"><a href="#📌-SwiftUI-的状态管理-数据绑定关键概念" class="headerlink" title="📌 SwiftUI 的状态管理 &amp; 数据绑定关键概念"></a>📌 SwiftUI 的状态管理 &amp; 数据绑定关键概念</h4><h4 id="1-State"><a href="#1-State" class="headerlink" title="1. @State"></a>1. @State</h4><p>✅ <strong>作用</strong>：在 <strong>当前视图 (<code>struct View</code>) 内部</strong> 管理 <strong>私有</strong> 状态。<br>✅ <strong>适用场景</strong>：变量仅在<strong>当前视图内部</strong>使用，不需要跨视图传递。<br>✅ <strong>存储位置</strong>：<code>SwiftUI</code> 自动管理，<code>@State</code> 变量会被 <code>SwiftUI</code> 视为<strong>源数据</strong><code>（Source of Truth）</code>。</p>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CounterView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// ✅ 只在本视图使用的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increment&quot;</span>) &#123;</span><br><span class="line">                count <span class="operator">+=</span> <span class="number">1</span>  <span class="comment">// ✅ 直接修改，SwiftUI 重新渲染 UI</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li><code>@State</code> <strong>只能用于 <code>struct View</code> 内部</strong>，不能用于 <code>class</code>。</li>
<li>不能在 <strong>不同视图</strong> 之间共享 <code>@State</code>，否则数据会不同步。</li>
<li><strong>变量变化时，整个视图会重新计算 <code>body</code>，触发 UI 更新。</strong></li>
</ul>
<hr>
<h4 id="2-Binding"><a href="#2-Binding" class="headerlink" title="2. @Binding"></a>2. @Binding</h4><p>✅ <strong>作用</strong>：<code>@Binding</code> 允许子视图 <strong>访问并修改父视图的 <code>@State</code> 变量</strong>，但不会自己存储数据。<br>✅ <strong>适用场景</strong>：子视图需要控制父视图的 <code>@State</code> 数据，而不自己管理状态。</p>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// ✅ 源数据（State）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">ChildView</span>(count: <span class="variable">$count</span>)  <span class="comment">// ✅ 传递 Binding</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> count: <span class="type">Int</span>  <span class="comment">// ✅ 绑定父视图的 `@State`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Increase&quot;</span>) &#123;</span><br><span class="line">            count <span class="operator">+=</span> <span class="number">1</span>  <span class="comment">// ✅ 修改时，`ParentView.count` 也会更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li><code>@Binding</code> <strong>不存储数据</strong>，它只是一个引用指针，绑定到 <code>@State</code> 的数据。</li>
<li><strong>适用于：</strong><ul>
<li>子视图 <strong>只修改数据，不拥有数据</strong> 的情况。</li>
<li><strong>避免在父子视图之间使用回调，提升代码简洁度</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-Binding"><a href="#3-Binding" class="headerlink" title="3. Binding"></a>3. Binding<T></h4><p>✅ <strong>作用</strong>：<code>Binding&lt;T&gt;</code> 是 <code>@Binding</code> 背后的数据类型，可以手动创建 <code>Binding</code> 以用于更复杂的场景。</p>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToggleSwitch</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> isOn: <span class="type">Binding</span>&lt;<span class="type">Bool</span>&gt;  <span class="comment">// ✅ 手动传递 Binding，而不是 `@Binding`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(title, isOn: isOn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isDarkMode <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ToggleSwitch</span>(title: <span class="string">&quot;Dark Mode&quot;</span>, isOn: <span class="variable">$isDarkMode</span>)  <span class="comment">// ✅ 传递 Binding</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<ul>
<li><code>@Binding</code> <strong>用于参数</strong>，而 <code>Binding&lt;T&gt;</code> <strong>用于手动创建绑定</strong>。</li>
<li><code>@Binding</code> 不能脱离 <code>@State</code>，但 <code>Binding&lt;T&gt;</code> 可以从 <code>State</code>、<code>Environment</code>、甚至 <code>Computed Property</code> 生成。</li>
</ul>
<hr>
<h4 id="4-ObservableObject"><a href="#4-ObservableObject" class="headerlink" title="4. @ObservableObject"></a>4. @ObservableObject</h4><p>✅ <strong>作用</strong>：用于<strong>类 (<code>class</code>)</strong>，让整个类的数据可以被 <code>SwiftUI</code> 监听，<strong>适用于多个视图共享数据</strong>。<br>✅ <strong>适用场景</strong>：</p>
<ul>
<li>需要跨多个视图共享状态。</li>
<li>需要监听 <code>class</code> 中属性的变化，并自动刷新 UI。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterModel</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// ✅ 被 SwiftUI 监听</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CounterView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">CounterModel</span>()  <span class="comment">// ✅ 视图绑定到 ObservableObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(model.count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase&quot;</span>) &#123;</span><br><span class="line">                model.count <span class="operator">+=</span> <span class="number">1</span>  <span class="comment">// ✅ 变化时 UI 自动更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li><code>ObservableObject</code> <strong>必须配合 <code>@StateObject</code> 或 <code>@ObservedObject</code> 在 SwiftUI 视图中使用</strong>。</li>
<li>需要在<strong>属性前使用 <code>@Published</code></strong>，否则 <code>SwiftUI</code> 不会监听到变化。</li>
</ul>
<hr>
<h4 id="5-Published"><a href="#5-Published" class="headerlink" title="5. @Published"></a>5. @Published</h4><p>✅ <strong>作用</strong>：<strong>在 <code>ObservableObject</code> 类中使用，确保 SwiftUI 监听数据变化</strong>。<br>✅ <strong>适用场景</strong>：</p>
<ul>
<li>让 <code>class</code> 内的属性可以被 SwiftUI 监听。</li>
<li>只有 <code>ObservableObject</code> <strong>内部的 <code>@Published</code> 变量</strong> 才会触发 UI 更新。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isDarkMode <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SettingsView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> settings <span class="operator">=</span> <span class="type">UserSettings</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(<span class="string">&quot;Dark Mode&quot;</span>, isOn: <span class="variable">$settings</span>.isDarkMode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li><code>@Published</code> <strong>只能用于 <code>class</code> 内部</strong>，不能用于 <code>struct</code>。</li>
<li>如果 <code>ObservableObject</code> 里的属性<strong>不加 <code>@Published</code>，数据改变时 UI 不会刷新！</strong></li>
</ul>
<hr>
<h4 id="6-StateObject-vs-ObservedObject"><a href="#6-StateObject-vs-ObservedObject" class="headerlink" title="6. @StateObject vs @ObservedObject"></a>6. @StateObject vs @ObservedObject</h4><table>
<thead>
<tr>
<th><strong>属性包装器</strong></th>
<th><strong>作用</strong></th>
<th><strong>生命周期</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@StateObject</code></td>
<td><strong>创建 <code>ObservableObject</code></strong></td>
<td><strong>随视图创建和销毁</strong></td>
<td><strong>View 内部管理状态</strong></td>
</tr>
<tr>
<td><code>@ObservedObject</code></td>
<td><strong>观察 <code>ObservableObject</code></strong></td>
<td><strong>由外部传入</strong></td>
<td><strong>子视图观察父视图的 <code>ObservableObject</code></strong></td>
</tr>
</tbody></table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">CounterModel</span>()  <span class="comment">// ✅ 创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ChildView</span>(model: model)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> model: <span class="type">CounterModel</span>  <span class="comment">// ✅ 观察</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Increase&quot;</span>) &#123; model.count <span class="operator">+=</span> <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li><code>@StateObject</code> <strong>只能用于创建</strong> <code>ObservableObject</code>，<strong>不能用于传递</strong>。</li>
<li><code>@ObservedObject</code> 适用于<strong>从父视图传递 <code>ObservableObject</code> 给子视图</strong>。</li>
</ul>
<hr>
<h4 id="7-Environment"><a href="#7-Environment" class="headerlink" title="7. @Environment"></a>7. @Environment</h4><p>✅ <strong>作用</strong>：用于 <strong>跨视图层级</strong> 共享全局状态。<br>✅ <strong>适用场景</strong>：</p>
<ul>
<li>共享 <strong>全局设置</strong>，如 <code>ColorScheme</code>、<code>Locale</code>、<code>UserDefaults</code> 数据等。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.colorScheme) <span class="keyword">var</span> colorScheme  <span class="comment">// ✅ 访问系统的颜色模式</span></span><br><span class="line">    <span class="meta">@Environment</span>(\.dismiss) <span class="keyword">private</span> <span class="keyword">var</span> dismiss  <span class="comment">// ✅ 访问系统的dismiss</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Current Mode: <span class="subst">\(colorScheme <span class="operator">==</span> .dark <span class="operator">?</span> <span class="string">&quot;Dark&quot;</span> : <span class="string">&quot;Light&quot;</span>)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="🛠-总结"><a href="#🛠-总结" class="headerlink" title="🛠 总结"></a>🛠 总结</h4><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>作用</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>使用位置</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@State</code></td>
<td>本地私有状态</td>
<td>当前视图</td>
<td><code>struct View</code></td>
</tr>
<tr>
<td><code>@Binding</code></td>
<td>绑定父视图的 <code>@State</code></td>
<td>子视图</td>
<td><code>struct View</code></td>
</tr>
<tr>
<td><code>@ObservedObject</code></td>
<td>观察 <code>ObservableObject</code></td>
<td>需要共享的 <code>ObservableObject</code></td>
<td><code>struct View</code></td>
</tr>
<tr>
<td><code>@StateObject</code></td>
<td>创建 <code>ObservableObject</code></td>
<td>视图管理 <code>ObservableObject</code></td>
<td><code>struct View</code></td>
</tr>
<tr>
<td><code>@Environment</code></td>
<td>访问全局环境值</td>
<td>访问系统或上层视图</td>
<td><code>struct View</code></td>
</tr>
<tr>
<td><code>@Published</code></td>
<td>触发 <code>ObservableObject</code> 变化</td>
<td><code>class</code> 内部</td>
<td><code>class</code></td>
</tr>
<tr>
<td><code>Binding&lt;T&gt;</code></td>
<td>手动创建 <code>@Binding</code></td>
<td>适用于更复杂绑定</td>
<td><code>struct View</code></td>
</tr>
</tbody></table>
<h4 id="🎯-记住："><a href="#🎯-记住：" class="headerlink" title="🎯 记住："></a>🎯 记住：</h4><ul>
<li><strong><code>@State</code> 自己管理数据</strong>，<code>@Binding</code> <strong>修改外部数据</strong>。</li>
<li><strong><code>@StateObject</code> 创建 <code>ObservableObject</code></strong>，<code>@ObservedObject</code> <strong>引用 <code>ObservableObject</code></strong>。</li>
<li><strong><code>@Environment</code> 访问全局状态</strong>。</li>
<li><strong><code>@Published</code> 让 <code>ObservableObject</code> 的属性可观察</strong>。</li>
</ul>
<p>这样，就能正确掌握 SwiftUI 的数据流 🚀！</p>
<hr>
<hr>
<h3 id="四、-Observable"><a href="#四、-Observable" class="headerlink" title="四、@Observable"></a>四、@Observable</h3><p><code>@Observable</code>、<code>@Bindable</code> 以及 <code>ObservableObject</code>、<code>@StateObject</code>以及 <code>@Published</code> 之间的联系和区别</p>
<h4 id="1-Observable-vs-ObservableObject-Published"><a href="#1-Observable-vs-ObservableObject-Published" class="headerlink" title="1. @Observable vs. ObservableObject + @Published"></a>1. @Observable vs. ObservableObject + @Published</h4><p><strong>✅ <code>@Observable</code>（Swift 5.9+ &#x2F; iOS 17+）</strong></p>
<ul>
<li><code>@Observable</code> <strong>是 Swift 5.9（iOS 17） 引入的新数据绑定机制</strong>，它是 <strong><code>ObservableObject</code> 的替代品</strong>。</li>
<li><strong>与 <code>@ObservableObject + @Published</code> 不同</strong>，<code>@Observable</code> <strong>可以自动检测属性变化</strong>，不需要手动加 <code>@Published</code>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>不需要 <code>@Published</code>，所有属性默认都可被监听</strong>（<strong>对 <code>class</code> 有效</strong>）。</li>
<li><strong>性能优化</strong>：<code>Swift</code> 编译器<strong>自动</strong>优化依赖跟踪，避免无效 <code>UI</code> 更新。</li>
<li><strong>更简洁</strong>，没有 <code>objectWillChange.send()</code> 手动触发的麻烦。</li>
</ul>
</li>
</ul>
<p><strong>❌ <code>ObservableObject</code> + <code>@Published</code>（Swift 5.8 及之前）</strong></p>
<ul>
<li>需要手动加 <code>@Published</code> 标记哪些属性需要触发 UI 变化。</li>
<li><code>ObservableObject</code> 使用 <code>objectWillChange.send()</code> <strong>通知 SwiftUI</strong>，但 <code>@Observable</code> <strong>不需要手动通知</strong>，自动追踪变化。</li>
</ul>
<p><strong>🌟 结论</strong><br>在我的 <code>ConfigModel</code> 使用了 <code>@Observable</code>，所以即使没有 <code>@Published</code>，<strong>它的属性变化仍然会触发 UI 更新</strong>。这就是 <code>@Observable</code> 的优势之一。</p>
<hr>
<h4 id="2-Bindable-vs-StateObject"><a href="#2-Bindable-vs-StateObject" class="headerlink" title="2. @Bindable vs. @StateObject"></a>2. @Bindable vs. @StateObject</h4><p><code>@Bindable</code> 和 <code>@StateObject</code> <strong>确实都可以让视图监听 <code>ConfigModel</code> 的数据变化</strong>，但它们的作用不同。</p>
<p><strong>✅ <code>@Bindable</code></strong></p>
<ul>
<li><strong>用于绑定 <code>@Observable</code> 类的属性</strong>，提供 <code>Binding</code> 访问，但不负责对象生命周期管理。</li>
<li>适用于 <strong>子视图接收 <code>@Observable</code> 对象的引用</strong>，而不是创建&#x2F;持有它。</li>
<li>依赖于 <code>@Observable</code> 提供的自动监听功能。</li>
</ul>
<p><strong>✅ <code>@StateObject</code></strong></p>
<ul>
<li><strong>管理 <code>ObservableObject</code> 实例的生命周期</strong>，确保对象在视图生命周期内存活。</li>
<li>适用于 <strong>视图内部创建 <code>ObservableObject</code> 并持有它</strong>。</li>
<li><strong>如果对象被 <code>@StateObject</code> 持有，它的生命周期和视图一致</strong>，即使视图 <code>body</code> 重新计算，也不会重新创建 <code>StateObject</code>。</li>
</ul>
<p><strong>🌟 代码对比</strong><br><strong><code>@StateObject</code> 的用法</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigurationSheetView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> reportConfig <span class="operator">=</span> <span class="type">ConfigurationManager</span>.shared.reportConfig</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(reportConfig.reportName) <span class="comment">// ✅ 视图会更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点：</strong></p>
<ul>
<li><code>@StateObject</code> <strong>管理 <code>reportConfig</code> 的生命周期</strong>。</li>
<li>如果 <code>ConfigurationSheetView</code> 重新创建，<code>reportConfig</code> <strong>不会丢失数据</strong>。</li>
</ul>
<hr>
<p><strong><code>@Bindable</code> 的用法</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigurationSheetView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Bindable</span> <span class="keyword">private</span> <span class="keyword">var</span> reportConfig <span class="operator">=</span> <span class="type">ConfigurationManager</span>.shared.reportConfig</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TextField</span>(<span class="string">&quot;Report Name&quot;</span>, text: <span class="variable">$reportConfig</span>.reportName) <span class="comment">// ✅ 自动绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点：</strong></p>
<ul>
<li><code>@Bindable</code> <strong>不会创建或持有 <code>reportConfig</code>，只是引用它</strong>。</li>
<li><code>@Bindable</code> <strong>允许 <code>TextField</code> 直接绑定到 <code>reportName</code></strong>，不需要 <code>Binding(get:set:)</code>。</li>
</ul>
<hr>
<h4 id="3-Bindable-和-StateObject-的核心区别"><a href="#3-Bindable-和-StateObject-的核心区别" class="headerlink" title="3. @Bindable 和 @StateObject 的核心区别"></a>3. @Bindable 和 @StateObject 的核心区别</h4><table>
<thead>
<tr>
<th><strong>属性包装器</strong></th>
<th><strong>作用</strong></th>
<th><strong>是否创建对象</strong></th>
<th><strong>是否管理生命周期</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@StateObject</code></td>
<td><strong>创建 &amp; 持有</strong> <code>ObservableObject</code></td>
<td>✅ <strong>是</strong></td>
<td>✅ <strong>是</strong></td>
<td>视图自己管理 <code>ObservableObject</code></td>
</tr>
<tr>
<td><code>@Bindable</code></td>
<td><strong>绑定 <code>@Observable</code> 数据</strong></td>
<td>❌ <strong>否</strong></td>
<td>❌ <strong>否</strong></td>
<td>视图引用 <code>@Observable</code> 对象，不管理生命周期</td>
</tr>
</tbody></table>
<p><strong>🌟 何时使用哪种？</strong></p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>使用 <code>@StateObject</code>？</strong></th>
<th><strong>使用 <code>@Bindable</code>？</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>视图创建并持有 <code>ObservableObject</code></strong></td>
<td>✅ <strong>是</strong></td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>父视图创建 <code>ObservableObject</code>，子视图绑定它</strong></td>
<td>❌ 否</td>
<td>✅ <strong>是</strong></td>
</tr>
<tr>
<td><strong>不希望 <code>ObservableObject</code> 被销毁</strong></td>
<td>✅ <strong>是</strong></td>
<td>❌ 否</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-Observable-和-Binding-结合"><a href="#4-Observable-和-Binding-结合" class="headerlink" title="4. @Observable 和 @Binding 结合"></a>4. @Observable 和 @Binding 结合</h4><p>有时，可能希望 <code>@Observable</code> 的属性能<strong>单独绑定到 UI 控件</strong>，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SubView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Bindable</span> <span class="keyword">var</span> config: <span class="type">ConfigModel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(<span class="string">&quot;Show xxxx&quot;</span>, isOn: <span class="variable">$config</span>.isShowxxxx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong></p>
<ul>
<li><code>@Bindable</code> <strong>让整个 <code>config</code> 可绑定</strong>。</li>
<li><code>$config.isShowxxxx</code> <strong>直接生成 <code>Binding&lt;Bool&gt;</code></strong>。</li>
</ul>
<hr>
<h4 id="5-Observable-是否适用于-struct-和-enum？"><a href="#5-Observable-是否适用于-struct-和-enum？" class="headerlink" title="5. @Observable 是否适用于 struct 和 enum？"></a>5. @Observable 是否适用于 struct 和 enum？</h4><p><strong>❌ 不能用于 <code>struct</code> 和 <code>enum</code></strong></p>
<ul>
<li><code>@Observable</code> 只能用于 <code>class</code>，因为 <code>SwiftUI</code> 需要监听对象属性变化，而 <code>struct</code> 是<strong>值类型</strong>，不适用于观察模式。</li>
</ul>
<p><strong>✅ <code>@State</code> 是 <code>struct</code> 的替代方案</strong><br>如果我需要 <code>struct</code> 管理状态，应该使用 <code>@State</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// ✅ struct 中使用 @State</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Increase&quot;</span>) &#123; count <span class="operator">+=</span> <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-什么时候用-Observable，什么时候用-ObservableObject？"><a href="#6-什么时候用-Observable，什么时候用-ObservableObject？" class="headerlink" title="6. 什么时候用 @Observable，什么时候用 ObservableObject？"></a>6. 什么时候用 @Observable，什么时候用 ObservableObject？</h4><table>
<thead>
<tr>
<th><strong>使用场景</strong></th>
<th><strong>推荐使用 <code>@Observable</code>？</strong></th>
<th><strong>推荐使用 <code>ObservableObject</code>？</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>iOS 17+ 项目</strong></td>
<td>✅ <strong>是</strong></td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>iOS 16 及以下项目</strong></td>
<td>❌ 否</td>
<td>✅ <strong>是</strong></td>
</tr>
<tr>
<td><strong>想要简化代码，不用 <code>@Published</code></strong></td>
<td>✅ <strong>是</strong></td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>想要手动触发 UI 更新</strong></td>
<td>❌ 否</td>
<td>✅ <strong>是</strong>（<code>objectWillChange.send()</code>）</td>
</tr>
</tbody></table>
<hr>
<h4 id="📌-结论"><a href="#📌-结论" class="headerlink" title="📌 结论"></a>📌 结论</h4><ol>
<li><strong><code>@Observable</code> 取代了 <code>ObservableObject</code> + <code>@Published</code>，不需要 <code>@Published</code> 也能自动监听变化</strong>。</li>
<li><strong><code>@Bindable</code> 适用于子视图引用 <code>@Observable</code> 数据，而 <code>@StateObject</code> 适用于视图自己管理 <code>ObservableObject</code>。</strong></li>
<li><strong><code>@StateObject</code> 管理对象生命周期，<code>@Bindable</code> 只是数据绑定，不管理生命周期。</strong></li>
<li><strong><code>@Observable</code> 只能用于 <code>class</code>，不能用于 <code>struct</code> 或 <code>enum</code></strong>。</li>
<li><strong>如果是 iOS 17+，推荐使用 <code>@Observable</code>，如果要兼容 iOS 16 及以下，仍然需要用 <code>ObservableObject</code> + <code>@Published</code>。</strong></li>
</ol>
<p>所以，在 <strong>iOS 17+</strong> 项目中，我可以放心使用 <code>@Observable</code> 和 <code>@Bindable</code>，这会让我的代码更简单、更清晰！🚀</p>
<hr>
<hr>
<h3 id="五、-StateObject-vs-Bindable"><a href="#五、-StateObject-vs-Bindable" class="headerlink" title="五、@StateObject vs @Bindable"></a>五、@StateObject vs @Bindable</h3><h4 id="问题-1：-StateObject-vs-Bindable-在生命周期管理上的差异"><a href="#问题-1：-StateObject-vs-Bindable-在生命周期管理上的差异" class="headerlink" title="问题 1：@StateObject vs @Bindable 在生命周期管理上的差异"></a>问题 1：@StateObject vs @Bindable 在生命周期管理上的差异</h4><p><strong><code>@StateObject</code> 和 <code>@Bindable</code> 都能让 SwiftUI 视图监听 <code>@Observable</code>（或 <code>ObservableObject</code>）的变化，但它们在 <strong>生命周期管理</strong> 上的行为完全不同。</strong></p>
<h4 id="✅-示例：-StateObject-负责对象生命周期"><a href="#✅-示例：-StateObject-负责对象生命周期" class="headerlink" title="✅ 示例：@StateObject 负责对象生命周期"></a>✅ 示例：<code>@StateObject</code> 负责对象生命周期</h4><p>在下面的代码中，我们的 <code>CounterModel</code> 是一个 <code>@Observable</code>（或 <code>ObservableObject</code>）的类，视图 <code>ParentView</code> 需要持有它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Observable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterModel</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">CounterModel</span>()  <span class="comment">// ✅ 由视图持有</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(model.count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">ChildView</span>(model: model)  <span class="comment">// 传递 `model` 给子视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> model: <span class="type">CounterModel</span>  <span class="comment">// 只是引用，不管理生命周期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Increment&quot;</span>) &#123;</span><br><span class="line">            model.count <span class="operator">+=</span> <span class="number">1</span>  <span class="comment">// ✅ 变化时，ParentView 也会更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="🛠-StateObject-的关键点"><a href="#🛠-StateObject-的关键点" class="headerlink" title="🛠 @StateObject&#96; 的关键点"></a>🛠 @StateObject&#96; 的关键点</h4><ol>
<li><strong><code>@StateObject</code> 确保 <code>CounterModel</code> 只被创建一次</strong>，并随着 <code>ParentView</code> 的生命周期存在。</li>
<li><strong>即使 <code>ParentView</code> 重新计算 <code>body</code>，<code>model</code> 依然是同一个实例</strong>。</li>
<li><strong>当 <code>ParentView</code> 被销毁时，<code>model</code> 也会被销毁</strong>，生命周期由 <code>@StateObject</code> 绑定。</li>
</ol>
<hr>
<h4 id="❌-如果错误使用-Bindable-代替-StateObject"><a href="#❌-如果错误使用-Bindable-代替-StateObject" class="headerlink" title="❌ 如果错误使用 @Bindable 代替 @StateObject"></a>❌ 如果错误使用 @Bindable 代替 @StateObject</h4><p>如果我们用 <code>@Bindable</code> 替代 <code>@StateObject</code>，它就不会管理 <code>model</code> 的生命周期，可能会导致<strong>错误的对象释放</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Bindable</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">CounterModel</span>()  <span class="comment">// ❌ 这样 `model` 的生命周期不受 `ParentView` 控制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(model.count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">ChildView</span>(model: model)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⚠️ 可能出现的问题</strong></p>
<ol>
<li><strong>每次 <code>ParentView</code> 重新计算 <code>body</code>，<code>CounterModel()</code> 可能会被重新创建</strong>，导致数据丢失。</li>
<li><strong>子视图 <code>ChildView</code> 可能会访问已被销毁的 <code>model</code>，导致应用崩溃或状态异常。</strong></li>
<li><strong>无法正确管理 <code>CounterModel</code> 的生命周期</strong>，如果 <code>model</code> 需要长期存在（比如在 <code>SettingsView</code> 共享用户设置），可能会意外销毁。</li>
</ol>
<hr>
<h4 id="✅-Bindable-正确的使用方式"><a href="#✅-Bindable-正确的使用方式" class="headerlink" title="✅ @Bindable 正确的使用方式"></a>✅ @Bindable 正确的使用方式</h4><p><code>@Bindable</code> <strong>只应该用于子视图，而不负责管理 <code>Observable</code> 对象的生命周期</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">CounterModel</span>()  <span class="comment">// ✅ 由 `@StateObject` 管理生命周期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Count: <span class="subst">\(model.count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">ChildView</span>(model: model)  <span class="comment">// ✅ 传递给子视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Bindable</span> <span class="keyword">var</span> model: <span class="type">CounterModel</span>  <span class="comment">// ✅ `@Bindable` 只是引用，不创建或管理 `model`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Increment&quot;</span>) &#123;</span><br><span class="line">            model.count <span class="operator">+=</span> <span class="number">1</span>  <span class="comment">// ✅ 变化会通知 `ParentView`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>✅ 这样不会重复创建 <code>model</code>，也不会导致 <code>model</code> 意外丢失或被销毁。</strong></p>
<hr>
<h4 id="🌟-总结-StateObject-vs-Bindable-的生命周期管理"><a href="#🌟-总结-StateObject-vs-Bindable-的生命周期管理" class="headerlink" title="🌟 总结 @StateObject vs @Bindable 的生命周期管理"></a>🌟 总结 @StateObject vs @Bindable 的生命周期管理</h4><table>
<thead>
<tr>
<th><strong>属性包装器</strong></th>
<th><strong>是否管理对象生命周期？</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@StateObject</code></td>
<td>✅ <strong>是</strong>，持有 <code>Observable</code> 对象</td>
<td>视图创建并管理 <code>Observable</code> 对象</td>
</tr>
<tr>
<td><code>@Bindable</code></td>
<td>❌ <strong>否</strong>，只做数据绑定</td>
<td>子视图引用 <code>@Observable</code> 数据，但不持有它</td>
</tr>
</tbody></table>
<p><strong>🚀 结论</strong></p>
<ul>
<li><strong><code>@StateObject</code> 适用于创建 <code>Observable</code> 对象，并管理它的生命周期。</strong></li>
<li><strong><code>@Bindable</code> 适用于引用 <code>Observable</code> 数据，但不会持有它。</strong></li>
<li><strong>错误使用 <code>@Bindable</code> 可能导致 <code>Observable</code> 被过早释放，或者在 <code>body</code> 重新计算时不断创建新的实例</strong>。</li>
</ul>
<hr>
<h4 id="问题-2：ObservableObject-Published-可以用于-struct-或-enum-吗？"><a href="#问题-2：ObservableObject-Published-可以用于-struct-或-enum-吗？" class="headerlink" title="问题 2：ObservableObject + @Published 可以用于 struct 或 enum 吗？"></a>问题 2：ObservableObject + @Published 可以用于 struct 或 enum 吗？</h4><p><strong>🚫 不能！</strong><br><code>ObservableObject</code> <strong>只能用于 <code>class</code></strong>，不能用于 <code>struct</code> 或 <code>enum</code>。<br><strong>原因</strong>：</p>
<ol>
<li><code>ObservableObject</code> <strong>依赖于 <code>objectWillChange.send()</code> 机制</strong>，而 <code>struct</code> 和 <code>enum</code> 是<strong>值类型</strong>，它们无法持有 <code>objectWillChange</code> 这样的引用对象。</li>
<li><code>@Published</code> <strong>只能用于 <code>ObservableObject</code> 内部的属性</strong>，而 <code>struct</code> <strong>不支持 <code>@Published</code></strong>。</li>
</ol>
<hr>
<h4 id="✅-struct-该怎么做？"><a href="#✅-struct-该怎么做？" class="headerlink" title="✅ struct 该怎么做？"></a>✅ <code>struct</code> 该怎么做？</h4><p>如果需要在 <code>struct</code> 中管理状态，应该使用 <code>@State</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CounterView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// ✅ 使用 `@State`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Increment&quot;</span>) &#123;</span><br><span class="line">            count <span class="operator">+=</span> <span class="number">1</span>  <span class="comment">// ✅ `@State` 变量变化时，UI 重新渲染</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="❌-如果错误地尝试用-Published-处理-struct"><a href="#❌-如果错误地尝试用-Published-处理-struct" class="headerlink" title="❌ 如果错误地尝试用 @Published 处理 struct"></a>❌ 如果错误地尝试用 @Published 处理 struct</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CounterModel</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;  <span class="comment">// ❌ `struct` 不能 conform `ObservableObject`</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// ❌ `@Published` 只能用于 `class`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🚨 报错！<code>ObservableObject</code> 只能用于 <code>class</code>，不能用于 <code>struct</code>。</strong></p>
<hr>
<h4 id="🌟-什么时候用-class（-Observable-或-ObservableObject），什么时候用-struct？"><a href="#🌟-什么时候用-class（-Observable-或-ObservableObject），什么时候用-struct？" class="headerlink" title="🌟 什么时候用 class（@Observable 或 ObservableObject），什么时候用 struct？"></a>🌟 什么时候用 class（@Observable 或 ObservableObject），什么时候用 struct？</h4><table>
<thead>
<tr>
<th><strong>情况</strong></th>
<th><strong>使用 <code>struct</code>（@State）</strong></th>
<th><strong>使用 <code>class</code>（@Observable）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态是局部的</strong>（仅用于当前视图）</td>
<td>✅ <code>@State</code></td>
<td>❌ 不适用</td>
</tr>
<tr>
<td><strong>多个视图需要共享数据</strong></td>
<td>❌ 不适用</td>
<td>✅ <code>@Observable</code></td>
</tr>
<tr>
<td><strong>需要监听对象内部属性的变化</strong></td>
<td>❌ <code>struct</code> 无法监听单个属性</td>
<td>✅ <code>@Observable</code>（iOS 17+）或 <code>ObservableObject + @Published</code></td>
</tr>
<tr>
<td><strong>需要传递给子视图</strong></td>
<td>✅ <code>@Binding</code></td>
<td>✅ <code>@Bindable</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="📌-结论-1"><a href="#📌-结论-1" class="headerlink" title="📌 结论"></a>📌 结论</h4><ol>
<li><strong><code>@StateObject</code> 负责管理 <code>Observable</code> 对象的生命周期，而 <code>@Bindable</code> 只是数据绑定，不持有对象</strong>。错误使用 <code>@Bindable</code> 可能会导致数据丢失或被过早销毁。</li>
<li><strong><code>ObservableObject</code> 只能用于 <code>class</code>，不能用于 <code>struct</code> 或 <code>enum</code></strong>。如果需要管理 <code>struct</code> 的状态，应该使用 <code>@State</code>。</li>
<li><strong><code>@Observable</code>（iOS 17+）取代了 <code>ObservableObject + @Published</code>，简化了数据监听机制，不需要 <code>@Published</code> 也能自动触发 UI 更新</strong>。</li>
<li><strong><code>@StateObject</code> 和 <code>@Bindable</code> 可以结合使用</strong>：<ul>
<li><strong><code>@StateObject</code> 创建并管理 <code>Observable</code></strong>。</li>
<li><strong><code>@Bindable</code> 让子视图引用 <code>Observable</code> 数据，而不持有它</strong>。</li>
</ul>
</li>
</ol>
<p>正确理解这些概念，就可以在 SwiftUI 中更好地管理数据流和状态！🚀</p>
<hr>
<hr>
<h3 id="六、SwiftUI-布局相关"><a href="#六、SwiftUI-布局相关" class="headerlink" title="六、SwiftUI 布局相关"></a>六、SwiftUI 布局相关</h3><h4 id="frame-maxWidth-infinity-maxHeight-infinity"><a href="#frame-maxWidth-infinity-maxHeight-infinity" class="headerlink" title=".frame(maxWidth: .infinity, maxHeight: .infinity)"></a>.frame(maxWidth: .infinity, maxHeight: .infinity)</h4><p>在 <strong>SwiftUI</strong> 中，<code>.frame(maxWidth: .infinity, maxHeight: .infinity)</code> 是一种 <strong>布局约束</strong>，用于指定视图的最大宽度和最大高度。</p>
<ul>
<li><strong><code>.frame(maxWidth: .infinity)</code></strong>：表示视图的宽度会尽可能地 <strong>扩展</strong>，直到 <strong>占据所有可用空间</strong>。<code>infinity</code> 表示无限制，所以它会填满可用的水平空间，通常是父视图所提供的空间。</li>
<li><strong><code>.frame(maxHeight: .infinity)</code></strong>：类似的，表示视图的高度会尽可能地 <strong>扩展</strong>，直到 <strong>占据所有可用空间</strong>。</li>
</ul>
<p><strong>示例说明</strong></p>
<p>假设我们在父视图中设置了 <code>.frame(maxWidth: .infinity, maxHeight: .infinity)</code>，这意味着 <strong>子视图将被拉伸到父视图的最大可用宽度和高度</strong>，并且它会占据尽可能多的空间。</p>
<p><strong>示例：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">        .frame(maxWidth: .infinity, maxHeight: .infinity) <span class="comment">// 这个文本会填满父视图的空间</span></span><br><span class="line">        .background(<span class="type">Color</span>.blue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>父视图</strong>（<code>VStack</code>）是容器，它可能有限制（例如屏幕或视图的大小）。</li>
<li><strong><code>Text(&quot;Hello, World!&quot;)</code></strong> 会 <strong>占据尽可能多的空间</strong>，并且背景是 <strong>蓝色的</strong>。</li>
</ul>
<hr>
<p><strong>具体含义和效果</strong></p>
<ul>
<li><strong>宽度：</strong> <code>.infinity</code> 表示该视图的宽度会自动适配父视图的宽度，通常会撑满整个父视图的宽度。</li>
<li><strong>高度：</strong> <code>.infinity</code> 也表示该视图的高度会适应父视图的高度，撑满整个父视图的高度。</li>
</ul>
<p><strong>常见场景</strong></p>
<ul>
<li><strong>布局组件</strong>：比如 <code>VStack</code>、<code>HStack</code>、<code>ZStack</code> 和 <code>GeometryReader</code> 等容器视图经常使用 <code>.frame(maxWidth: .infinity, maxHeight: .infinity)</code> 来填满父视图的空间。</li>
<li><strong>可变高度的内容</strong>：如果需要视图根据内容动态调整大小，但不希望它超出父视图的边界，可以使用 <code>.frame(maxWidth: .infinity, maxHeight: .infinity)</code>。</li>
</ul>
<p><strong>🚀总结</strong><br><code>.frame(maxWidth: .infinity, maxHeight: .infinity)</code> 使视图的 <strong>宽度和高度尽可能扩展</strong>，使其 <strong>填充父视图的可用空间</strong>。</p>
<hr>
<h4 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h4><p><strong>代码解析：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> groupSize <span class="operator">=</span> <span class="type">NSCollectionLayoutSize</span>(</span><br><span class="line">    widthDimension: .estimated(<span class="keyword">self</span>.cellWidth <span class="operator">*</span> <span class="type">CGFloat</span>(<span class="keyword">self</span>.headerTitles.count)),</span><br><span class="line">    heightDimension: .absolute(<span class="keyword">self</span>.cellHeight)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>NSCollectionLayoutSize</code></strong> 定义了一个组（group）中元素的尺寸。<ul>
<li><code>widthDimension: .estimated(self.cellWidth * CGFloat(self.headerTitles.count))</code>：设置组的宽度为 <strong>估算宽度</strong>。估算的宽度是 <code>cellWidth</code> （每个单元格的宽度）与 <code>headerTitles.count</code> （列数）相乘的值。这意味着每行的宽度大约等于 <code>cellWidth</code> 乘以列数，但由于是估算，最终宽度会自动调整以适应父容器。</li>
<li><code>heightDimension: .absolute(self.cellHeight)</code>：设置组的 <strong>固定高度</strong>，即每一行的高度将为 <code>cellHeight</code> 的值。</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">NSCollectionLayoutGroup</span>.horizontal(</span><br><span class="line">    layoutSize: groupSize,</span><br><span class="line">    subitem: item,</span><br><span class="line">    count: <span class="keyword">self</span>.headerTitles.count</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>NSCollectionLayoutGroup.horizontal</code></strong> 创建了一个水平排列的 <strong>组（group）</strong>，包含多个单元项（<code>subitem</code>）。<ul>
<li><code>layoutSize: groupSize</code>：使用上面定义的 <code>groupSize</code> 来设置组的尺寸，即每行的宽度和高度。</li>
<li><code>subitem: item</code>：表示每个单元格（item）的布局。这是 <code>NSCollectionLayoutItem</code>，它定义了每个单元格的尺寸。</li>
<li><code>count: self.headerTitles.count</code>：定义了该组包含的 <strong>单元格数</strong>，即每行有多少个单元格（列数），通常与 <code>headerTitles.count</code> 相同，表示每一列一个单元格。</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.interItemSpacing <span class="operator">=</span> .fixed(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>interItemSpacing</code></strong> 设置组内单元格之间的间距，这里使用 <code>.fixed(1)</code> 来确保每两个单元格之间有 <strong>1 点的固定间距</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> section <span class="operator">=</span> <span class="type">NSCollectionLayoutSection</span>(group: group)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>NSCollectionLayoutSection</code></strong> 是集合视图中的一个部分，它表示一组有共同布局的元素。这里将前面定义的 <code>group</code> 作为该部分的内容。<ul>
<li><code>group: group</code>：设置该部分的内容为先前创建的水平排列的 <code>group</code>，即水平排列的一行。</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section.interGroupSpacing <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>interGroupSpacing</code></strong> 设置不同组之间的间距，这里设置为 <strong>1 点</strong>。即在每行（<code>group</code>）之间会有 1 点的间隔。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section.contentInsets <span class="operator">=</span> <span class="type">NSDirectionalEdgeInsets</span>(top: <span class="number">1</span>, leading: <span class="number">1</span>, bottom: <span class="number">1</span>, trailing: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>contentInsets</code></strong> 设置视图的内边距（padding）。这里使用 <code>NSDirectionalEdgeInsets</code> 来设置四个方向的内边距：<ul>
<li><code>top: 1</code>：顶部内边距为 1 点。</li>
<li><code>leading: 1</code>：左侧内边距为 1 点。</li>
<li><code>bottom: 1</code>：底部内边距为 1 点。</li>
<li><code>trailing: 1</code>：右侧内边距为 1 点。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong><br>这段代码配置了一个水平排列的 <strong>组（group）</strong>，每一行包含多个单元格，每个单元格的宽度由列数和每列的宽度决定，且具有固定的高度。每个单元格之间有 1 点的间距，每行之间也有 1 点的间距，并且整个 <code>section</code> 有一定的内边距。</p>
<hr>
<h4 id="UICollectionView-在拖拽时无法固定在一个水平或垂直的滑动区域"><a href="#UICollectionView-在拖拽时无法固定在一个水平或垂直的滑动区域" class="headerlink" title="UICollectionView 在拖拽时无法固定在一个水平或垂直的滑动区域"></a>UICollectionView 在拖拽时无法固定在一个水平或垂直的滑动区域</h4><p><strong>UICollectionView</strong> 在拖拽时无法固定在一个水平或垂直的滑动区域，而是上下大幅度拖拽。这种情况通常是由于 <strong><code>UICollectionView</code> 的布局配置</strong> 或 <strong><code>contentSize</code> 的设置</strong> 不正确导致的，或者是 <code>UICollectionView</code> 的滚动方向和滑动方式没有正确设置。</p>
<p>以下是几种可能的原因和解决方案：</p>
<ol>
<li><strong>检查布局设置</strong></li>
</ol>
<p>我这里使用的是 <code>UICollectionViewCompositionalLayout</code> 来配置我的 <code>UICollectionView</code>，请确保布局是正确设置的。</p>
<p><strong>解决方案：</strong><br>确保为 <code>UICollectionViewCompositionalLayout</code> 设置了正确的方向，尤其是在我的布局中设置了 <strong><code>horizontal</code></strong> 和 <strong><code>vertical</code></strong> 方向的滑动。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layout <span class="operator">=</span> <span class="type">UICollectionViewCompositionalLayout</span> &#123; sectionIndex, environment -&gt; <span class="type">NSCollectionLayoutSection</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> itemSize <span class="operator">=</span> <span class="type">NSCollectionLayoutSize</span>(widthDimension: .absolute(<span class="keyword">self</span>.cellWidth), heightDimension: .absolute(<span class="keyword">self</span>.cellHeight))</span><br><span class="line">    <span class="keyword">let</span> item <span class="operator">=</span> <span class="type">NSCollectionLayoutItem</span>(layoutSize: itemSize)</span><br><span class="line">    item.contentInsets <span class="operator">=</span> <span class="type">NSDirectionalEdgeInsets</span>(top: <span class="number">1</span>, leading: <span class="number">1</span>, bottom: <span class="number">1</span>, trailing: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 group 的大小为水平排列</span></span><br><span class="line">    <span class="keyword">let</span> groupSize <span class="operator">=</span> <span class="type">NSCollectionLayoutSize</span>(widthDimension: .estimated(<span class="keyword">self</span>.cellWidth <span class="operator">*</span> <span class="type">CGFloat</span>(<span class="keyword">self</span>.headerTitles.count)), heightDimension: .absolute(<span class="keyword">self</span>.cellHeight))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">NSCollectionLayoutGroup</span>.horizontal(layoutSize: groupSize, subitem: item, count: <span class="keyword">self</span>.headerTitles.count)</span><br><span class="line">    group.interItemSpacing <span class="operator">=</span> .fixed(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> section <span class="operator">=</span> <span class="type">NSCollectionLayoutSection</span>(group: group)</span><br><span class="line">    section.interGroupSpacing <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    section.contentInsets <span class="operator">=</span> <span class="type">NSDirectionalEdgeInsets</span>(top: <span class="number">1</span>, leading: <span class="number">1</span>, bottom: <span class="number">1</span>, trailing: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保布局的 <strong><code>group</code></strong> 是 <strong>水平排列</strong>，而不是垂直排列。如果布局是水平滚动的，应该设置 <code>NSCollectionLayoutGroup.horizontal</code>。如果希望 <strong>水平滑动</strong>，确保它是设置为 <strong>水平排列的组</strong>。</p>
<ol start="2">
<li><strong>滚动方向设置</strong></li>
</ol>
<p>确认我的 <code>UICollectionView</code> 的滚动方向是否正确设置。如果我的 <code>UICollectionView</code> 应该水平滚动而不是垂直滚动，那么要确保它的 <code>isScrollEnabled</code> 和布局方向是正确的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collectionView <span class="operator">=</span> <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: layout)</span><br><span class="line">collectionView.alwaysBounceHorizontal <span class="operator">=</span> <span class="literal">true</span>  <span class="comment">// 允许水平滚动</span></span><br><span class="line">collectionView.showsHorizontalScrollIndicator <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 禁用水平滚动指示器</span></span><br><span class="line">collectionView.showsVerticalScrollIndicator <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 禁用垂直滚动指示器</span></span><br></pre></td></tr></table></figure>

<p>在 <code>UICollectionView</code> 的 <strong><code>alwaysBounceHorizontal</code></strong> 设置为 <code>true</code> 后，用户可以水平拖动，而 <strong><code>showsVerticalScrollIndicator</code></strong> 为 <code>false</code> 则隐藏垂直滚动条。</p>
<ol start="3">
<li><strong>确保 <code>contentSize</code> 正确</strong></li>
</ol>
<p><code>UICollectionView</code> 的 <strong><code>contentSize</code></strong> 控制了它是否允许滚动。如果 <code>contentSize</code> 过大或过小，可能会导致内容在拖拽时无法正常滚动。确保我的内容区有足够的尺寸来支持滚动。</p>
<p><strong>解决方案：</strong><br>确保我在布局中设置的大小符合实际的需求。如果 <code>UICollectionView</code> 没有正确地计算其内容区域的大小，可能会导致滚动区域不固定。</p>
<ol start="4">
<li><strong>禁用垂直滑动</strong></li>
</ol>
<p>如果我的 <code>UICollectionView</code> 是 <strong>水平滑动</strong> 的，但拖动时有大幅度的垂直滑动，可能是因为垂直方向的滑动没有被限制。</p>
<p><strong>解决方案：</strong><br>如果想禁用垂直滑动，可以设置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collectionView.alwaysBounceVertical <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 禁用垂直滑动</span></span><br><span class="line">collectionView.isScrollEnabled <span class="operator">=</span> <span class="literal">true</span>  <span class="comment">// 确保滚动是启用的</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>确保没有多余的外部滚动视图</strong></li>
</ol>
<p>如果我的 <code>UICollectionView</code> 被嵌套在多个滚动视图中，可能会出现滚动冲突，导致它无法固定在水平或垂直的滑动区域。</p>
<p><strong>解决方案：</strong><br>如果 <code>UICollectionView</code> 在其他 <strong><code>ScrollView</code></strong> 或 <strong><code>GeometryReader</code></strong> 中，确保设置正确的 <strong>滚动行为</strong>，以防止冲突。确保外部的 <code>ScrollView</code> 不干扰内部的 <code>UICollectionView</code> 滚动。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(.horizontal, showsIndicators: <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="type">UICollectionView</span>(<span class="operator">...</span>)  <span class="comment">// 放入内嵌的 UICollectionView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>测试修改后的布局</strong></li>
</ol>
<p>最后，可以逐步测试这些修改，确保 <strong><code>UICollectionView</code></strong> 在目标滚动方向上能保持稳定。</p>
<p><strong>总结：</strong></p>
<ol>
<li>确保布局是正确配置的，特别是 <code>UICollectionViewCompositionalLayout</code> 的方向。</li>
<li>设置 <code>UICollectionView</code> 的滚动方向，确保 <strong>水平滑动</strong> 或 <strong>垂直滑动</strong> 正常工作。</li>
<li>确保内容区域 (<code>contentSize</code>) 没有过大或过小，导致无法固定滑动区域。</li>
<li>禁用不需要的滚动方向，避免出现意外的滑动效果。</li>
<li>如果有外部容器视图，确保不会干扰 <code>UICollectionView</code> 的滑动行为。</li>
</ol>
<hr>
<h4 id="transition-opacity"><a href="#transition-opacity" class="headerlink" title=".transition(.opacity)"></a>.transition(.opacity)</h4><p><code>.transition(.opacity)</code> 是 <strong>SwiftUI</strong> 中的一个动画效果，用来指定视图在 <strong>进入或离开屏幕时</strong> 应该如何过渡（动画效果）。在这个例子中，<code>.transition(.opacity)</code> 指定了一个 <strong>透明度变化</strong> 的动画效果。</p>
<p><strong>具体含义：</strong></p>
<ul>
<li><strong><code>transition</code></strong> 是一个修饰符，用于控制视图在状态变化时的 <strong>过渡动画</strong>。</li>
<li><strong><code>.opacity</code></strong> 是一种预定义的过渡类型，表示视图在 <strong>进入或离开时</strong> 会通过 <strong>渐变</strong> 的方式改变透明度。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>当视图 <strong>出现（进入屏幕）</strong> 时，它从透明到完全可见，形成渐显动画。</li>
<li>当视图 <strong>消失（离开屏幕）</strong> 时，它会从完全可见变为透明，形成渐隐动画。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isVisible &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">            .transition(.opacity)  <span class="comment">// 透明度渐变动画</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.onTapGesture &#123;</span><br><span class="line">    withAnimation &#123;</span><br><span class="line">        isVisible.toggle()  <span class="comment">// 点击切换视图显示或隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ol>
<li><strong><code>Text(&quot;Hello, World!&quot;)</code></strong> 是一个视图，在 <code>isVisible</code> 为 <code>true</code> 时显示。</li>
<li><strong><code>.transition(.opacity)</code></strong>：当 <code>Text</code> 视图显示或消失时，透明度会随着视图的出现或离开发生渐变变化。</li>
<li><strong><code>withAnimation</code></strong>：使视图的状态变化（在这里是 <code>isVisible</code>）伴随动画效果，进而触发 <code>.opacity</code> 过渡效果。</li>
</ol>
<p><strong>效果：</strong></p>
<ul>
<li>当 <code>isVisible</code> 变为 <code>true</code> 时，<code>Text</code> 从完全透明（透明度为 0）逐渐变为完全可见（透明度为 1），产生一个淡入（fade in）效果。</li>
<li>当 <code>isVisible</code> 变为 <code>false</code> 时，<code>Text</code> 会从完全可见逐渐消失，产生一个淡出（fade out）效果。</li>
</ul>
<p><strong>总结：</strong><br><code>.transition(.opacity)</code> 用于设置视图的透明度动画，使得视图在出现和消失时有 <strong>渐变透明度</strong> 的效果，从而让界面切换看起来更加流畅和自然。</p>
<hr>
<h4 id="padding-和-contentMargins"><a href="#padding-和-contentMargins" class="headerlink" title="padding 和 contentMargins"></a>padding 和 contentMargins</h4><p>在 <strong>SwiftUI</strong> 中，<code>contentMargins</code> 和 <code>padding</code> 是用于控制视图内外间距的常见布局修饰符。</p>
<p><strong>1. <code>padding</code></strong></p>
<p><code>padding</code> 是一个非常常用的修饰符，用来设置视图 <strong>内容与视图边缘之间的距离</strong>。它可以被用来增加内边距，使视图的内容不会直接触碰到视图的边缘。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    .padding() <span class="comment">// 在所有四个方向上添加默认的 16 点内边距</span></span><br></pre></td></tr></table></figure>

<p><strong>指定具体方向的内边距：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    .padding(.top, <span class="number">20</span>) <span class="comment">// 只设置顶部的内边距为 20 点</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>.padding()</code></strong>：在所有方向上都应用默认的内边距。</li>
<li><strong><code>.padding(.horizontal)</code></strong>：同时应用左右方向的内边距。</li>
<li><strong><code>.padding(.vertical)</code></strong>：同时应用上下方向的内边距。</li>
<li><strong><code>.padding(.top)</code></strong>、<strong><code>.padding(.leading)</code>、</strong><code>.padding(.bottom)</code>、**<code>.padding(.trailing)</code>：设置特定方向的内边距。</li>
</ul>
<p><strong>设置内边距的大小：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    .padding(<span class="number">30</span>) <span class="comment">// 在所有方向上添加 30 点内边距</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>30</code> 是一个 <strong>具体的数值</strong>，设置为在所有四个方向上使用 30 点的内边距。</li>
</ul>
<p><strong>组合多个方向：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    .padding([.top, .leading], <span class="number">20</span>) <span class="comment">// 设置顶部和左侧的内边距为 20 点</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>[方向]</code></strong> 允许同时对多个方向应用内边距。</li>
</ul>
<p><strong>2. <code>contentMargins</code></strong></p>
<p><code>contentMargins</code> 用于设置视图内容的外边距。它并不是 <strong>SwiftUI</strong> 的一个直接修饰符，而通常与 <code>GeometryReader</code> 配合使用，或者在一些复杂视图中，作为容器设置的一部分。<code>contentMargins</code> 控制视图的整体布局空间，包括 <strong>视图的内外边距</strong>。</p>
<p>在 <strong>SwiftUI</strong> 中，<code>contentMargins</code> 并不是常用的标准修饰符。通常更常用的是 <code>padding</code> 来实现类似效果。如果想要调整内外间距，并且有一些特定的布局需求，<code>contentMargins</code> 可能出现在一些容器视图中，比如 <code>List</code> 或 <code>ScrollView</code> 等，它们会根据容器的设置应用一些内外边距。</p>
<p><strong>3. <code>padding</code> 和 <code>contentMargins</code> 设置方式总结：</strong></p>
<ul>
<li><strong>设置内边距：</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .padding() <span class="comment">// 给所有方向添加默认的 16 点内边距</span></span><br><span class="line"></span><br><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .padding(.horizontal, <span class="number">20</span>) <span class="comment">// 给水平（左右）方向添加 20 点内边距</span></span><br><span class="line"></span><br><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .padding(.vertical, <span class="number">10</span>) <span class="comment">// 给垂直（上下）方向添加 10 点内边距</span></span><br><span class="line"></span><br><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .padding([.top, .leading], <span class="number">15</span>) <span class="comment">// 给顶部和左边设置 15 点内边距</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>组合外边距和内边距：</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        .padding(.horizontal, <span class="number">20</span>) <span class="comment">// 水平内边距为 20</span></span><br><span class="line">        .background(<span class="type">Color</span>.blue)</span><br><span class="line">&#125;</span><br><span class="line">.padding(.top, <span class="number">30</span>) <span class="comment">// 外部的顶部边距为 30</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 内边距与外边距的区别：</strong></p>
<ul>
<li><strong><code>padding</code></strong> 用于视图 <strong>内容与视图边缘之间的间距</strong>。可以通过设置 <code>padding</code> 来增加视图内容的可视空间，通常是 <strong>视图内部的间距</strong>。</li>
<li><strong><code>contentMargins</code></strong> 是用来表示视图的 <strong>内外边距空间</strong>。在一些容器组件中，它用于设置容器的整体间距，通常会影响视图的 <strong>外部布局空间</strong>。</li>
</ul>
<p><strong>5. 示例：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">        .padding(.horizontal, <span class="number">20</span>) <span class="comment">// 左右内边距</span></span><br><span class="line">        .background(<span class="type">Color</span>.green)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;SwiftUI Tutorial&quot;</span>)</span><br><span class="line">        .padding([.top, .bottom], <span class="number">10</span>) <span class="comment">// 上下内边距</span></span><br><span class="line">        .background(<span class="type">Color</span>.orange)</span><br><span class="line">&#125;</span><br><span class="line">.padding(<span class="number">30</span>) <span class="comment">// 整个 VStack 外部 30 点边距</span></span><br></pre></td></tr></table></figure>

<p>这个例子中：</p>
<ul>
<li><code>Text(&quot;Welcome!&quot;)</code> 使用了水平内边距，填充了左右空间。</li>
<li><code>Text(&quot;SwiftUI Tutorial&quot;)</code> 使用了上下内边距。</li>
<li>整个 <code>VStack</code> 被赋予了 30 点的外部边距。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong><code>padding</code></strong> 是设置视图内容的内边距的修饰符，允许控制视图与父视图或边缘的间距。</li>
<li><strong><code>contentMargins</code></strong> 在 <strong>SwiftUI</strong> 中并不直接提供作为一个标准修饰符使用，但在一些容器视图中可以作为布局的一部分来调整外边距，通常通过类似于 <code>padding</code> 的方式设置。</li>
</ul>
<hr>
<hr>
<p>你碰到这个编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializer is inaccessible due to &#x27;private&#x27; protection level</span><br></pre></td></tr></table></figure>

<p>是在使用 <code>private var foregroundStyleScale: [Color] = [...]</code> 和 <code>private var symbolScale: [...]</code> 时触发的，而将其改成 <code>var</code> 或 <code>private let</code> 却不会报错。</p>
<hr>
<hr>
<h3 id="七、SwiftUI-中是否还需要-MVVM？"><a href="#七、SwiftUI-中是否还需要-MVVM？" class="headerlink" title="七、SwiftUI 中是否还需要 MVVM？"></a>七、SwiftUI 中是否还需要 MVVM？</h3><p><code>SwiftUI</code> 虽然本身支持状态驱动的视图更新，但并不等于不需要 <code>ViewModel</code>。<code>MVVM</code> 在 <code>SwiftUI</code> 中的作用主要是<strong>解耦视图和业务逻辑、状态管理和数据处理</strong>，它依然能带来以下好处：</p>
<ul>
<li><strong>清晰的职责分层</strong>：视图只负责 <code>UI</code>，逻辑放在 <code>ViewModel</code>；</li>
<li><strong>更好的测试性</strong>：<code>ViewModel</code> 便于单元测试；</li>
<li><strong>提升可维护性和可复用性</strong>：不同视图之间可以共享同一个 <code>ViewModel</code>；</li>
<li><strong>避免视图中出现太多逻辑代码</strong>，提升代码可读性。</li>
</ul>
<hr>
<hr>
<h3 id="八、SwiftUI-生命周期问题、异步数据加载和状态管理"><a href="#八、SwiftUI-生命周期问题、异步数据加载和状态管理" class="headerlink" title="八、SwiftUI 生命周期问题、异步数据加载和状态管理"></a>八、SwiftUI 生命周期问题、异步数据加载和状态管理</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.task &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="type">ReportManager</span>.shared.processReportData(with: uRL)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">ReportManager</span>.shared.isDataLoaded <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="type">ReportManager</span>.shared.allRows.isEmpty &#123;</span><br><span class="line">        viewModel.loadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.onAppear &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">ReportManager</span>.shared.processReportData(with: uRL)</span><br><span class="line">        <span class="keyword">if</span> <span class="type">ReportManager</span>.shared.isDataLoaded <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="type">ReportManager</span>.shared.allRows.isEmpty &#123;</span><br><span class="line">            viewModel.loadData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我在 <code>onAppear</code> 使用 <code>Task</code>，解析数据 <code>ReportManager.shared.processReportData(with: uRL)</code><br>我解析完之后，<code>ReportManager.shared.isDataLoaded</code> 的状态是飘忽不定的<br>当我想使用 <code>ReportManager.shared.isDataLoaded</code> 控制状态的时候，我明明知道<code>ReportManager.shared.isDataLoaded</code> 还没有解析完为 <code>false</code>，但是它的值先为 <code>true</code>，后面才会变化成正确的状态。但是我直接使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.task &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">ReportManager</span>.shared.processReportData(with: uRL)</span><br><span class="line">            <span class="keyword">if</span> <span class="type">ReportManager</span>.shared.isDataLoaded <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="type">ReportManager</span>.shared.allRows.isEmpty &#123;</span><br><span class="line">                viewModel.loadData()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>就能很好的控制状态</p>
<hr>
<p><strong>这个问题实际上是与 <code>SwiftUI</code> 的生命周期、异步数据加载和状态管理相关的。具体来说，问题的本质原因在于 <code>onAppear</code> 和 <code>task</code> 以及异步数据加载的执行时机和更新策略之间的交互。</strong></p>
<p><strong>问题分析</strong></p>
<ol>
<li><p><strong>异步数据加载和生命周期问题：</strong></p>
<ul>
<li>在 <code>SwiftUI</code> 中，<code>onAppear</code> 是在视图显示时触发的。然而，<code>onAppear</code> 的触发时机并不是非常明确，尤其是当我在视图展示后需要异步加载数据时，<code>task</code> 方法提供的异步任务可能会被并行执行。</li>
<li>当我在 <code>onAppear</code> 中启动 <code>Task</code> 来处理异步操作时，<code>SwiftUI</code> 的视图生命周期仍然在控制，因此在视图加载时，异步任务可能尚未完成，但 UI 可能已经渲染并显示出状态变化，导致 <code>isDataLoaded</code> 状态不一致或者飘忽不定。</li>
</ul>
</li>
<li><p><strong><code>task</code> 与 <code>onAppear</code> 的区别：</strong></p>
<ul>
<li><code>task</code> 是专门用于启动异步任务的一个修饰符，它能够确保异步操作与当前视图的生命周期同步，并且任务会在视图出现时开始执行。它有明确的控制逻辑，可以保证异步任务的顺序执行和视图更新。</li>
<li><code>onAppear</code> 是 <code>SwiftUI</code> 的视图生命周期钩子，虽然它会在视图出现时触发，但它可能没有完全同步地与视图的渲染周期对接。尤其是在处理异步数据时，<code>onAppear</code> 内的异步任务可能会在视图还未完全渲染时就启动，导致状态不一致。</li>
</ul>
</li>
<li><p><strong>状态变化滞后和同步问题：</strong></p>
<ul>
<li><code>isDataLoaded</code> 在 <code>ReportManager</code> 中可能会在异步加载数据后被更新。由于我在 <code>onAppear</code> 中启动异步任务，<code>SwiftUI</code> 可能在异步任务完成之前就渲染了界面，导致状态标志变化滞后，甚至被错误地设为 <code>true</code>。</li>
</ul>
</li>
</ol>
<p><strong>为什么 <code>.task</code> 解决了问题</strong></p>
<ul>
<li><code>task</code> 修饰符是在 <code>SwiftUI</code> 视图出现时启动异步任务，并确保视图的生命周期与异步任务的执行顺序保持一致。在我直接使用 <code>task</code> 时，<code>ReportManager.shared.processReportData(with: uRL)</code> 任务完成后，只有当 <code>isDataLoaded</code> 被正确设置为 <code>true</code> 并且数据加载完毕时，才会执行接下来的数据处理逻辑。</li>
<li>使用 <code>.task</code> 时，<code>SwiftUI</code> 会确保异步任务执行完毕并且状态更新后，才进行界面更新，这样我就能控制状态的变化，并保证数据加载的顺序。</li>
</ul>
<p><strong>如何避免此类问题</strong></p>
<ol>
<li><p><strong>优先使用 <code>task</code> 处理异步任务：</strong></p>
<ul>
<li>如果我需要在视图出现时处理异步数据加载，优先使用 <code>task</code> 修饰符，因为它提供了明确的异步任务执行机制，并且能确保视图的更新与异步操作同步进行。</li>
</ul>
</li>
<li><p><strong>避免 <code>onAppear</code> 中的异步操作：</strong></p>
<ul>
<li>尽量避免在 <code>onAppear</code> 中启动复杂的异步操作，尤其是在需要确保任务执行顺序和数据完整性的情况下。将异步任务和视图渲染分离可以让我更清晰地控制状态更新。</li>
</ul>
</li>
<li><p><strong>明确标记和监听数据加载状态：</strong></p>
<ul>
<li>使用 <code>@State</code> 或 <code>@ObservedObject</code> 来监听数据加载的状态，并根据状态显示相关 UI。确保 <code>isDataLoaded</code> 在正确的时机进行更新，并且在数据加载完成前，UI 显示正确的“加载中”状态。</li>
</ul>
</li>
<li><p><strong>使用 <code>async/await</code> 明确控制执行顺序：</strong></p>
<ul>
<li>在需要确保执行顺序的情况下，可以使用 <code>async/await</code> 来明确控制任务的顺序，例如在 <code>task</code> 中调用 <code>await</code> 来确保任务完成后再执行接下来的操作。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>task</code> 修饰符能确保异步任务执行顺序和视图更新同步，避免了 <code>onAppear</code> 中的异步问题。</li>
<li>尽量避免在 <code>onAppear</code> 中直接执行复杂的异步操作，尤其是在需要确保数据加载顺序和视图更新时。</li>
<li>使用 <code>async/await</code> 明确控制任务执行顺序，确保数据加载完成后再进行界面更新。</li>
</ul>
<hr>
<hr>
<h3 id="九、SwiftUI-编译报错"><a href="#九、SwiftUI-编译报错" class="headerlink" title="九、SwiftUI 编译报错"></a>九、SwiftUI 编译报错</h3><h4 id="1-Struct-‘YourViewName’-has-no-initializers"><a href="#1-Struct-‘YourViewName’-has-no-initializers" class="headerlink" title="1.Struct ‘YourViewName’ has no initializers"></a>1.Struct ‘YourViewName’ has no initializers</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Struct &#x27;YourViewName&#x27; has no initializers</span><br><span class="line">Stored property &#x27;foregroundStyleScale&#x27; without initial value prevents synthesized initializers</span><br></pre></td></tr></table></figure>

<p>❗问题发生的根本原因：</p>
<p>在 <code>View</code> 结构体里这样声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> foregroundStyleScale: [<span class="type">Color</span>] <span class="operator">=</span> [.red, .orange, .yellow, .mint]</span><br></pre></td></tr></table></figure>

<p>这会 <strong>被 Swift 编译器解释为一个 <em>stored property</em>（存储属性）</strong>。</p>
<p>而 <code>SwiftUI</code> 的 <code>View</code> 是一个 <strong>值类型的 protocol（struct）</strong>，不允许普通的存储属性 —— 除非它是：</p>
<ul>
<li><code>@State</code>、<code>@Binding</code>、<code>@Environment</code> 等修饰的；</li>
<li>或者是 <code>let</code> 常量（编译器允许其当作常量初始化期间编译展开）；</li>
<li>或者是 <strong>非私有</strong> 的属性，且在初始化时传入（因为 <code>SwiftUI</code> 要生成自动合成的初始化器）。</li>
</ul>
<hr>
<p>💡 所以这几种写法的行为不同：</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>SwiftUI 能接受？</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>private var foregroundStyleScale = [...]</code></td>
<td>❌ <strong>报错</strong></td>
<td><code>SwiftUI</code> 无法在自动合成的 <code>init</code> 中访问 <code>private</code> <code>stored var</code></td>
</tr>
<tr>
<td><code>var foregroundStyleScale = [...]</code></td>
<td>✅</td>
<td>默认是 <code>internal</code>，<code>SwiftUI</code> 生成的 <code>init</code> 可以访问它</td>
</tr>
<tr>
<td><code>private let foregroundStyleScale = [...]</code></td>
<td>✅</td>
<td>常量，允许内联构造，不依赖外部 <code>init</code></td>
</tr>
<tr>
<td><code>let foregroundStyleScale = [...]</code></td>
<td>✅</td>
<td>同上，且允许自动合成 <code>init</code></td>
</tr>
</tbody></table>
<hr>
<p>✅ 推荐的安全写法：</p>
<ol>
<li>如果值不需要修改（只是配置常量）：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> foregroundStyleScale: [<span class="type">Color</span>] <span class="operator">=</span> [.red, .orange, .yellow, .mint]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果希望根据其他属性动态返回，可以改为 <strong>计算属性</strong>：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> foregroundStyleScale: [<span class="type">Color</span>] &#123;</span><br><span class="line">    [.red, .orange, .yellow, .mint]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>🧠 延伸：为什么 <code>private var</code> 不行？</p>
<p>因为 <code>SwiftUI</code> 的 <code>View</code> 是这样设计的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GroupPointMarkChartView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chartData: <span class="type">LineChartData</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 cChartData 是初始化时必须传入的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当添加了 <code>private var foregroundStyleScale</code> 这种 <strong>存储变量</strong>时，<strong>SwiftUI 无法自动生成包含这个私有属性的初始化器</strong>，从而导致 <strong>View 初始化失败</strong>，这就是你看到的编译报错。</p>
<hr>
<p>✅ 总结</p>
<ul>
<li>使用 <code>private var ... = [...]</code> 会创建一个“隐形的存储属性”，SwiftUI 不允许它；</li>
<li>用 <code>let</code> 或改为计算属性是最安全的；</li>
<li>如果必须是 <code>var</code>（并非 <code>let</code>），要保证不是 <code>private</code>，否则 SwiftUI 无法合成对应的初始化器；</li>
<li>SwiftUI 是一个声明式 UI 框架，对 <code>View</code> 结构体中的属性限制很多，是为了保持可追踪性和稳定的重绘机制。</li>
</ul>
<hr>
<hr>
<h4 id="2-No-exact-matches-in-reference-to-static-method-‘buildExpression’"><a href="#2-No-exact-matches-in-reference-to-static-method-‘buildExpression’" class="headerlink" title="2.No exact matches in reference to static method ‘buildExpression’"></a>2.No exact matches in reference to static method ‘buildExpression’</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **Content area (dynamic switching)**</span></span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                <span class="type">MyReportView</span>(csvURL: csvURL)</span><br><span class="line">            &#125;</span><br><span class="line">我这样的时候可以正常运行</span><br><span class="line"></span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> selectedView &#123;</span><br><span class="line">                <span class="keyword">case</span> .table:</span><br><span class="line">                    <span class="type">MyReportView</span>(csvURL: csvURL)</span><br><span class="line">                <span class="keyword">case</span> .pieChart:</span><br><span class="line">                    <span class="type">MyReportPieChartView</span>(csvURL: csvURL)</span><br><span class="line">                <span class="keyword">case</span> .lineChart:</span><br><span class="line">                    <span class="type">MyReportLineChartView</span>(csvURL: csvURL)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>编译时 <code>Xcode</code> 提示在 <code>MyReportView(csvURL: csvURL)</code> 处报错：<strong><code>No exact matches in reference to static method &#39;buildExpression&#39;</code></strong></p>
<ul>
<li>这种报错一般是指：<strong>表示在某些地方类型不匹配或者 <code>SwiftUI</code> 无法正确推断类型。</strong></li>
</ul>
<hr>
<p><strong>根本原因分析：</strong></p>
<ol>
<li><p><strong>类型推断问题：</strong><br><code>SwiftUI</code> 中的 <code>Group</code> 会将其包含的所有视图推断成同一个类型。如果在 <code>Group</code> 中有多个 <code>View</code>，并且这些视图的类型不一致，<code>SwiftUI</code> 就无法推断出它们的共同类型，因此会导致编译报错。这里，<code>MyReportView(csvURL: csvURL)</code>、<code>MyReportPieChartView()</code> 和 <code>MyReportLineChartView()</code> 由于视图结构不完全一致，因此导致了类型推断失败。</p>
</li>
<li><p><strong><code>switch</code> 语句和类型推断：</strong><br>当在 <code>switch</code> 语句中切换视图时，<code>SwiftUI</code> 需要通过类型推断来确定每个 <code>case</code> 的返回值。然而，<code>MyReportView</code> 需要一个 <code>csvURL</code> 参数，而 <code>MyReportPieChartView</code> 和 <code>MyReportLineChartView</code> 没有这个参数。当它们都包含在同一个 <code>Group</code> 内时，<code>SwiftUI </code>无法保证返回的视图类型一致。</p>
</li>
<li><p><strong><code>buildExpression</code> 错误：</strong><br><code>SwiftUI</code> 编译器通过 <code>buildExpression</code> 方法来处理视图的构建。如果在 <code>switch</code> 语句中传递不同类型的视图（比如 <code>MyReportView</code> 和没有 <code>csvURL</code> 的其他视图），<code>SwiftUI</code> 无法通过类型推断确定每个视图的类型，并且无法正确调用 <code>buildExpression</code> 方法，因此报错：<code>No exact matches in reference to static method &#39;buildExpression&#39;</code>。</p>
</li>
</ol>
<p><strong>内部原因：</strong></p>
<ul>
<li><p><strong>类型不一致</strong>：在 <code>switch</code> 语句中，<code>MyReportView</code> 需要 <code>csvURL</code> 作为初始化参数，但 <code>MyReportPieChartView</code> 和 <code>MyReportLineChartView</code> 并没有这个参数。<code>SwiftUI</code> 的 <code>Group</code> 无法处理不同类型的视图，因为它期望 <code>Group</code> 中的所有视图具有一致的类型。</p>
</li>
<li><p><strong><code>buildExpression</code> 是一个构建 SwiftUI 表达式的机制</strong>：<code>SwiftUI</code> 依赖 <code>buildExpression</code> 来解析 <code>View</code> 类型。如果存在类型不一致的问题，它就无法正确处理这个表达式，导致编译时出错。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<p><strong>1. 确保每个视图都有一致的参数类型：</strong></p>
<p>   如果希望 <code>MyReportView</code>、<code>MyReportPieChartView</code> 和 <code>MyReportLineChartView</code> 都能接受 <code>csvURL</code>，那么需要为这些视图都添加 <code>csvURL</code> 属性，并在初始化时传递 <code>csvURL</code>。</p>
<p>   <strong>修改方式</strong>：</p>
<ul>
<li>给 <code>MyReportPieChartView</code> 和 <code>MyReportLineChartView</code> 添加 <code>csvURL</code> 属性。</li>
<li>在 <code>switch</code> 语句中，确保每个视图都接受相同的参数。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportPieChartView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> csvURL: <span class="type">URL</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Pie Chart View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportLineChartView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> csvURL: <span class="type">URL</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Line Chart View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ReportViewType</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> table, pieChart, lineChart</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedView: <span class="type">ReportViewType</span> <span class="operator">=</span> .table</span><br><span class="line">    <span class="keyword">let</span> csvURL: <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="comment">// **Content area (dynamic switching)**</span></span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> selectedView &#123;</span><br><span class="line">                <span class="keyword">case</span> .table:</span><br><span class="line">                    <span class="type">MyReportView</span>(csvURL: csvURL)</span><br><span class="line">                <span class="keyword">case</span> .pieChart:</span><br><span class="line">                    <span class="type">MyReportPieChartView</span>(csvURL: csvURL)</span><br><span class="line">                <span class="keyword">case</span> .lineChart:</span><br><span class="line">                    <span class="type">MyReportLineChartView</span>(csvURL: csvURL)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .frame(maxWidth: .infinity, maxHeight: .infinity)</span><br><span class="line">            .transition(.opacity)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 或者将不需要参数的视图修改为不接收参数：</strong></p>
<p>   如果 <code>MyReportPieChartView</code> 和 <code>MyReportLineChartView</code> 并不需要 <code>csvURL</code> 参数，可以直接去掉 <code>csvURL</code> 的传递，改成无参数的初始化方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportPieChartView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Pie Chart View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportLineChartView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Line Chart View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ReportViewType</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> table, pieChart, lineChart</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedView: <span class="type">ReportViewType</span> <span class="operator">=</span> .table</span><br><span class="line">    <span class="keyword">let</span> csvURL: <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="comment">// **Content area (dynamic switching)**</span></span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> selectedView &#123;</span><br><span class="line">                <span class="keyword">case</span> .table:</span><br><span class="line">                    <span class="type">MyReportView</span>(csvURL: csvURL)</span><br><span class="line">                <span class="keyword">case</span> .pieChart:</span><br><span class="line">                    <span class="type">MyReportPieChartView</span>()</span><br><span class="line">                <span class="keyword">case</span> .lineChart:</span><br><span class="line">                    <span class="type">MyReportLineChartView</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .frame(maxWidth: .infinity, maxHeight: .infinity)</span><br><span class="line">            .transition(.opacity)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><strong>编译时错误</strong>：<code>No exact matches in reference to static method &#39;buildExpression&#39;</code> 是由于 <code>switch</code> 中的 <code>MyReportView(csvURL: csvURL)</code> 和其他视图（<code>MyReportPieChartView</code>、<code>MyReportLineChartView</code>）之间的类型不一致引起的。</li>
<li><strong>解决方案</strong>：要么确保所有视图都接受相同的参数（例如 <code>csvURL</code>），要么确保每个视图都不需要参数并进行相应调整。</li>
</ul>
<hr>
<hr>
<h4 id="3-swiftUI-传递参数问题"><a href="#3-swiftUI-传递参数问题" class="headerlink" title="3.swiftUI 传递参数问题"></a>3.swiftUI 传递参数问题</h4><p><code>MyReportView</code> 里面相关的属性如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyReportView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> csvURL: <span class="type">URL</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isLoading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> errorMessage: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 <code>MyReportView</code> 初始化的时候时候必须带上参数 <code>csvURL</code>，就是  <code>MyReportView(csvURL: csvURL)</code> 这样初始化，而其余的属性值不需要放在初始化里面？</p>
<hr>
<p><strong>问题分析：</strong></p>
<ul>
<li><code>MyReportView(csvURL: csvURL)</code> 必须传递 <code>csvURL</code> 参数，而 <code>MyReportPieChartView()</code> 和 <code>MyReportLineChartView()</code> 没有接收 <code>csvURL</code> 参数，这导致了在 <code>switch</code> 语句中出现了类型不一致的问题。由于 <code>MyReportView</code> 需要 <code>csvURL</code> 这个初始化参数，而其他视图没有这个参数，<code>SwiftUI</code> 不能在 <code>switch</code> 语句中推断出一致的视图类型，因而报错。</li>
</ul>
<p><strong>为什么 <code>MyReportView</code> 需要 <code>csvURL</code> 参数：</strong></p>
<p>在 <code>SwiftUI</code> 中，每个视图的 <code>init</code> 方法需要参数时，必须明确传递这些参数。在 <code>MyReportView</code> 中，<code>csvURL</code> 是一个 <code>let</code> 常量属性，它在初始化时被传递。这是因为 <code>csvURL</code> 可能是这个视图的核心数据源，用来加载 CSV 数据。因此，<code>csvURL</code> 在视图初始化时必须提供，以便视图能够正确加载并处理数据。</p>
<p><strong>为什么其他属性不需要在初始化时传递：</strong></p>
<p>在 <code>SwiftUI</code> 中，视图的属性通常有两种方式：</p>
<ol>
<li><strong><code>let</code> 常量属性：</strong> <code>let</code> 属性在初始化时必须提供。这些属性需要通过初始化方法传递参数。</li>
<li><strong><code>@State</code>、<code>@Binding</code> 和其他状态属性：</strong> 这些属性是由 <code>SwiftUI</code> 管理的，并且它们会在视图生命周期中动态更新。所以这些属性不需要在初始化时传递。</li>
</ol>
<p><code>@State</code> 和类似的属性是由 <code>SwiftUI</code> 自动管理的，它们是绑定到视图状态的。当视图的状态发生变化时，<code>SwiftUI</code> 会自动重新渲染视图。比如 <code>@State private var isLoading = false</code> 就是一个状态变量，<code>SwiftUI</code> 会在需要时自动更新这个变量的值，而不需要在初始化时传递。</p>
<p><strong>SwiftUI 独有的写法：</strong></p>
<p>在 <code>SwiftUI</code> 中，<code>@State</code>、<code>@Binding</code> 等属性是 <code>SwiftUI</code> 特有的，用于管理视图的状态。它们与普通的 <code>Swift</code> 对象不同，后者通常会依赖于初始化方法来传递所有的属性。</p>
<p>在一般的 <code>Swift</code> 对象中，所有的属性通常都会在初始化时传递或赋值。而在 <code>SwiftUI</code> 中，<code>@State</code> 和 <code>@Binding</code> 等属性则不需要在初始化时传递，因为它们会自动管理视图的状态。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong><code>csvURL</code> 参数</strong>： <code>MyReportView</code> 需要 <code>csvURL</code> 参数来初始化，因为它是视图的核心数据源，而其他视图可以根据需要选择是否传递该参数。</li>
<li><strong><code>@State</code> 属性</strong>： 这些属性是由 <code>SwiftUI</code> 自动管理的，通常不需要在初始化时传递。</li>
<li><strong>类型一致性</strong>：确保在 <code>switch</code> 中的每个分支返回的视图类型一致，或确保没有参数时使用默认初始化。</li>
</ul>
<hr>
<hr>
<h4 id="4-No-matching-navigationDestination-declaration"><a href="#4-No-matching-navigationDestination-declaration" class="headerlink" title="4.No matching navigationDestination declaration&#96;"></a>4.No matching navigationDestination declaration&#96;</h4><p>我先导航进入另外一个页面，退出后点击 <code>ReportListView</code> 中的 <code>item</code> 想进入<code>ReportContentView</code> 的时候。无法导航进入。且报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A NavigationLink is presenting a value of type “MyReport” but there is no matching navigationDestination declaration visible from the location of the link. The link cannot be activated.</span><br><span class="line"></span><br><span class="line">Note: Links search for destinations in any surrounding NavigationStack, then within the same column of a NavigationSplitView.</span><br></pre></td></tr></table></figure>
<p><code>ReportListView</code> 中进入对应 <code>ReportContentView</code> 的处理是这么写的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> reports: [<span class="type">MyReport</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line"><span class="type">NavigationStack</span> &#123;</span><br><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(reports) &#123; report <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span>(value: report) &#123;</span><br><span class="line">                    <span class="type">HStack</span> &#123;</span><br><span class="line">                        <span class="type">Image</span>(systemName: selectedReports.contains(report) <span class="operator">?</span> <span class="string">&quot;checkmark.circle.fill&quot;</span> : <span class="string">&quot;circle&quot;</span>)</span><br><span class="line">                            .animation(.default, value: selectedReports.contains(report))</span><br><span class="line">                            .foregroundStyle(selectedReports.contains(report) <span class="operator">?</span> <span class="type">Color</span>.green : <span class="type">Color</span>.gray)</span><br><span class="line">                            .onTapGesture &#123;</span><br><span class="line">                                toggleSelection(for: report)</span><br><span class="line">                            &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// call a custom view to display report information</span></span><br><span class="line">                        reportLabel(for: report)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationDestination(for: <span class="type">MyReport</span>.<span class="keyword">self</span>) &#123; report <span class="keyword">in</span></span><br><span class="line">            <span class="type">ReportContentView</span>(csvURL: report.url)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开始以为是 <code>@State private var reports: [MyReport] = []</code> 标记的数据为临时数据，后面发现 <code>ReportListView</code> 的父控件 <code>ReportView</code> 里面已经包装了 <code>NavigationStack</code>，好像就是这里导致的冲突，引发的报错</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReportView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> reportType: <span class="keyword">Self</span>.<span class="type">ReportType</span> <span class="operator">=</span> .appXXXX</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> logger: <span class="type">Logger</span> <span class="operator">=</span> .<span class="keyword">init</span>(subsystem: <span class="string">&quot;com.xxxx&quot;</span>, category: <span class="string">&quot;ReportView&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> <span class="keyword">self</span>.reportType &#123;</span><br><span class="line">                <span class="keyword">case</span> .appXXXX:</span><br><span class="line">                    <span class="type">ARReportView</span>()</span><br><span class="line">                <span class="keyword">case</span> .pipXXXX:</span><br><span class="line">                    <span class="type">ReportListView</span>()</span><br><span class="line">                <span class="keyword">case</span> .chXXXX:</span><br><span class="line">                    <span class="type">LogListView</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;Report&quot;</span>)</span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这个问题，是在导航层次上存在冲突，导致无法成功导航。这里的关键问题是我在 <code>ReportView</code> 和 <code>ReportListView</code> 中都使用了 <code>NavigationStack</code>，这会导致导航目标不可见，从而引发错误。</p>
<p><strong>根本原因：</strong></p>
<ul>
<li><p><strong>重复的 <code>NavigationStack</code>：</strong> 当我在 <code>ReportView</code> 中使用了一个 <code>NavigationStack</code>，然后在 <code>ReportListView</code> 内部又使用了一个 <code>NavigationStack</code>，这就导致了嵌套的导航栈。<code>SwiftUI</code> 的 <code>NavigationStack</code> 是一个上下文管理器，它应该只存在一个父 <code>NavigationStack</code> 来控制整个视图栈。嵌套多个 <code>NavigationStack</code> 会导致导航目的地无法识别，进而导致无法正确激活链接。</p>
</li>
<li><p><strong><code>NavigationLink</code> 和 <code>navigationDestination</code> 配对的问题：</strong> <code>NavigationLink</code> 使用 <code>NavigationStack</code> 来管理其导航目的地。当我为 <code>MyReport</code> 创建了 <code>NavigationLink</code> 并且指定了 <code>navigationDestination(for: MyReport.self)</code>，需要确保这个 <code>NavigationStack</code> 是唯一的，并且能够正确处理目标视图。</p>
</li>
</ul>
<p><strong>解决方案：</strong><br>我只需要在 <code>ReportView</code> 中保留一个 <code>NavigationStack</code>，然后在 <code>ReportListView</code> 中移除 <code>NavigationStack</code>，这能确保导航目的地正确识别。具体可以按以下步骤修改：</p>
<p><strong>1. 移除 <code>ReportListView</code> 中的 <code>NavigationStack</code>：</strong></p>
<p>   <code>ReportListView</code> 只需要负责展示列表，具体的导航管理交给 <code>ReportView</code> 来处理。所以，在 <code>ReportListView</code> 中删除 <code>NavigationStack</code>，只保留导航目标的 <code>navigationDestination</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReportListView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> reports: [<span class="type">MyReport</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(reports) &#123; report <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span>(value: report) &#123;</span><br><span class="line">                    <span class="type">HStack</span> &#123;</span><br><span class="line">                        <span class="type">Image</span>(systemName: selectedReports.contains(report) <span class="operator">?</span> <span class="string">&quot;checkmark.circle.fill&quot;</span> : <span class="string">&quot;circle&quot;</span>)</span><br><span class="line">                            .animation(.default, value: selectedReports.contains(report))</span><br><span class="line">                            .foregroundStyle(selectedReports.contains(report) <span class="operator">?</span> <span class="type">Color</span>.green : <span class="type">Color</span>.gray)</span><br><span class="line">                            .onTapGesture &#123;</span><br><span class="line">                                toggleSelection(for: report)</span><br><span class="line">                            &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Custom view to display report information</span></span><br><span class="line">                        reportLabel(for: report)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationDestination(for: <span class="type">MyReport</span>.<span class="keyword">self</span>) &#123; report <span class="keyword">in</span></span><br><span class="line">            <span class="type">ReportContentView</span>(csvURL: report.url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 确保 <code>ReportView</code> 中唯一的 <code>NavigationStack</code> 负责整个导航栈：</strong></p>
<p>   在 <code>ReportView</code> 中，继续使用 <code>NavigationStack</code> 来包裹整个内容，包括 <code>ReportListView</code>。这样，<code>ReportListView</code> 的 <code>NavigationLink</code> 会根据 <code>navigationDestination</code> 进行正常跳转。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReportView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> reportType: <span class="keyword">Self</span>.<span class="type">ReportType</span> <span class="operator">=</span> .appXXXX</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> logger: <span class="type">Logger</span> <span class="operator">=</span> .<span class="keyword">init</span>(subsystem: <span class="string">&quot;com.XXXX&quot;</span>, category: <span class="string">&quot;ReportView&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> <span class="keyword">self</span>.reportType &#123;</span><br><span class="line">                <span class="keyword">case</span> .appXXXX:</span><br><span class="line">                    <span class="type">ARReportView</span>()</span><br><span class="line">                <span class="keyword">case</span> .pipXXXX:</span><br><span class="line">                    <span class="type">ReportListView</span>()</span><br><span class="line">                <span class="keyword">case</span> .chXXXX:</span><br><span class="line">                    <span class="type">LogListView</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;Report&quot;</span>)</span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么这么做有效？</strong></p>
<ul>
<li><p><strong>单一的 <code>NavigationStack</code></strong>：通过在 <code>ReportView</code> 中保留唯一的 <code>NavigationStack</code>，它会负责整个导航栈的管理，包括 <code>ReportListView</code> 中的 <code>NavigationLink</code>。<code>navigationDestination</code> 会在父 <code>NavigationStack</code> 中生效，从而确保能够正确导航到目标视图。</p>
</li>
<li><p><strong>避免重复的导航栈</strong>：避免在 <code>ReportListView</code> 中再次包裹 <code>NavigationStack</code>，这样 <code>NavigationLink</code> 可以正确识别并跳转到目标视图（<code>ReportContentView</code>）。</p>
</li>
</ul>
<p><strong>总结：</strong><br>遇到的报错 <code>No matching navigationDestination declaration</code> 是因为在 <code>ReportView</code> 和 <code>ReportListView</code> 中都使用了 <code>NavigationStack</code>，导致了嵌套的导航栈冲突。通过移除 <code>ReportListView</code> 中的 <code>NavigationStack</code>，并确保在 <code>ReportView</code> 中只使用一个 <code>NavigationStack</code>，可以解决这个问题，并使得 <code>NavigationLink</code> 正常工作。</p>
<hr>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tuberose621.github.io">葛聪颖</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tuberose621.github.io/2025/05/07/SwiftUI%20%E5%AD%A6%E4%B9%A0/">https://tuberose621.github.io/2025/05/07/SwiftUI%20%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://tuberose621.github.io" target="_blank">技术成长笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SwiftUI/">SwiftUI</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/07/Swift%20%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-Task%20%E5%92%8C%20async-await%20/" title="Swift 中的函数式编程以及 Task 和 async/await 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Swift 中的函数式编程以及 Task 和 async/await 的使用</div></div><div class="info-2"><div class="info-item-1">一、函数式编程风格在下面的代码中： 123456let entries = try store    .getEntries(at: position)    .compactMap &#123; $0 as? OSLogEntryLog &#125;    .filter &#123; $0.subsystem == Bundle.main.bundleIdentifier! &#125;    .filter &#123; $0.date &gt;= date &#125;    .map &#123; &quot;[\(self.dateFormatter.string(from: $0.date))][\((OSLogLevel(rawValue: $0.level.rawValue) ?? .undefined).title)][\($0.category)] \($0.composedMessage)&quot; &#125;  compactMap：将集合中每个元素转换为某类型，如果转换失败则过滤掉 nil。   filter：筛选集合中满足条件的元素。 ...</div></div></div></a><a class="pagination-related" href="/2025/06/06/%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE/" title="漂亮的使用协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">漂亮的使用协议</div></div><div class="info-2"><div class="info-item-1">我现在做金融 App 的组件化重构，正好处于需要用“协议优先、服务解耦”思维的阶段。  📚 1️⃣ 什么是“协议优先，服务解耦”？✅ 协议优先（Protocol First）核心思想：  先定义好“接口协议”（Protocol / Interface / API） → 再实现功能 调用方（UI &#x2F; 上层逻辑）只依赖接口，不依赖具体实现 具体实现可以替换、升级、扩展，调用方无需改动  👉 重点是“先设计接口” → “后实现功能” → 保证灵活性和解耦  ✅ 服务解耦（Service Decoupling）核心思想：  各模块 &#x2F; 各服务之间通过接口交互，不直接依赖彼此内部细节 模块内部变化 → 不影响其它模块 可以独立开发、独立测试、独立发布   🎯 2️⃣ 举个简单例子（结合金融 App） 传统耦合代码（不解耦）：123// UI 层直接 new Service，并调用内部方法let macdCalculator = MACDCalculator()let result = macdCalculator.calculate(data:...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">葛聪颖</div><div class="author-info-description">记录 iOS 架构设计、组件化实践、AI 工具探索与技术成长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-SwiftUI-%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE%E7%94%A8-struct-%E8%80%8C%E4%B8%8D%E6%98%AF-class"><span class="toc-number">1.</span> <span class="toc-text">一、为什么 SwiftUI 中的视图用 struct 而不是 class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、声明式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">一、什么是声明式编程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%BE%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%EF%BC%88iOS-%E7%BC%96%E7%A8%8B%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">🔍 举个简单例子（iOS 编程场景）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%EF%BC%88UIKit%EF%BC%89%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">命令式（UIKit）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%EF%BC%88SwiftUI%EF%BC%89%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">声明式（SwiftUI）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">二、声明式编程的核心特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81SwiftUI-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%93%E7%8E%B0%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">三、SwiftUI 是怎么体现声明式编程的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9ASwiftUI-vs-UIKit-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">四、总结：SwiftUI vs UIKit 编程范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%8E%B0%E5%AE%9E%E5%90%AF%E7%A4%BA"><span class="toc-number">2.8.</span> <span class="toc-text">五、现实启示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81SwiftUI-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%9A%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">三、SwiftUI 状态管理 &amp; 数据绑定：全面解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-SwiftUI-%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">📌 SwiftUI 的状态管理 &amp; 数据绑定关键概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-State"><span class="toc-number">3.2.</span> <span class="toc-text">1. @State</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Binding"><span class="toc-number">3.3.</span> <span class="toc-text">2. @Binding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Binding"><span class="toc-number">3.4.</span> <span class="toc-text">3. Binding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ObservableObject"><span class="toc-number">3.5.</span> <span class="toc-text">4. @ObservableObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Published"><span class="toc-number">3.6.</span> <span class="toc-text">5. @Published</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-StateObject-vs-ObservedObject"><span class="toc-number">3.7.</span> <span class="toc-text">6. @StateObject vs @ObservedObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Environment"><span class="toc-number">3.8.</span> <span class="toc-text">7. @Environment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9B%A0-%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">🛠 总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8E%AF-%E8%AE%B0%E4%BD%8F%EF%BC%9A"><span class="toc-number">3.10.</span> <span class="toc-text">🎯 记住：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-Observable"><span class="toc-number">4.</span> <span class="toc-text">四、@Observable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Observable-vs-ObservableObject-Published"><span class="toc-number">4.1.</span> <span class="toc-text">1. @Observable vs. ObservableObject + @Published</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Bindable-vs-StateObject"><span class="toc-number">4.2.</span> <span class="toc-text">2. @Bindable vs. @StateObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Bindable-%E5%92%8C-StateObject-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">3. @Bindable 和 @StateObject 的核心区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Observable-%E5%92%8C-Binding-%E7%BB%93%E5%90%88"><span class="toc-number">4.4.</span> <span class="toc-text">4. @Observable 和 @Binding 结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Observable-%E6%98%AF%E5%90%A6%E9%80%82%E7%94%A8%E4%BA%8E-struct-%E5%92%8C-enum%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">5. @Observable 是否适用于 struct 和 enum？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-Observable%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-ObservableObject%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">6. 什么时候用 @Observable，什么时候用 ObservableObject？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-%E7%BB%93%E8%AE%BA"><span class="toc-number">4.7.</span> <span class="toc-text">📌 结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-StateObject-vs-Bindable"><span class="toc-number">5.</span> <span class="toc-text">五、@StateObject vs @Bindable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1%EF%BC%9A-StateObject-vs-Bindable-%E5%9C%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.1.</span> <span class="toc-text">问题 1：@StateObject vs @Bindable 在生命周期管理上的差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%EF%BC%9A-StateObject-%E8%B4%9F%E8%B4%A3%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.</span> <span class="toc-text">✅ 示例：@StateObject 负责对象生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9B%A0-StateObject-%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">🛠 @StateObject&#96; 的关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%8C-%E5%A6%82%E6%9E%9C%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8-Bindable-%E4%BB%A3%E6%9B%BF-StateObject"><span class="toc-number">5.4.</span> <span class="toc-text">❌ 如果错误使用 @Bindable 代替 @StateObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-Bindable-%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">✅ @Bindable 正确的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-%E6%80%BB%E7%BB%93-StateObject-vs-Bindable-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">🌟 总结 @StateObject vs @Bindable 的生命周期管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2%EF%BC%9AObservableObject-Published-%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E-struct-%E6%88%96-enum-%E5%90%97%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">问题 2：ObservableObject + @Published 可以用于 struct 或 enum 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-struct-%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">✅ struct 该怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%8C-%E5%A6%82%E6%9E%9C%E9%94%99%E8%AF%AF%E5%9C%B0%E5%B0%9D%E8%AF%95%E7%94%A8-Published-%E5%A4%84%E7%90%86-struct"><span class="toc-number">5.9.</span> <span class="toc-text">❌ 如果错误地尝试用 @Published 处理 struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-class%EF%BC%88-Observable-%E6%88%96-ObservableObject%EF%BC%89%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-struct%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">🌟 什么时候用 class（@Observable 或 ObservableObject），什么时候用 struct？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-%E7%BB%93%E8%AE%BA-1"><span class="toc-number">5.11.</span> <span class="toc-text">📌 结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81SwiftUI-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">六、SwiftUI 布局相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#frame-maxWidth-infinity-maxHeight-infinity"><span class="toc-number">6.1.</span> <span class="toc-text">.frame(maxWidth: .infinity, maxHeight: .infinity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UICollectionView"><span class="toc-number">6.2.</span> <span class="toc-text">UICollectionView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UICollectionView-%E5%9C%A8%E6%8B%96%E6%8B%BD%E6%97%B6%E6%97%A0%E6%B3%95%E5%9B%BA%E5%AE%9A%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%B0%B4%E5%B9%B3%E6%88%96%E5%9E%82%E7%9B%B4%E7%9A%84%E6%BB%91%E5%8A%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">6.3.</span> <span class="toc-text">UICollectionView 在拖拽时无法固定在一个水平或垂直的滑动区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transition-opacity"><span class="toc-number">6.4.</span> <span class="toc-text">.transition(.opacity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#padding-%E5%92%8C-contentMargins"><span class="toc-number">6.5.</span> <span class="toc-text">padding 和 contentMargins</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81SwiftUI-%E4%B8%AD%E6%98%AF%E5%90%A6%E8%BF%98%E9%9C%80%E8%A6%81-MVVM%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">七、SwiftUI 中是否还需要 MVVM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81SwiftUI-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98%E3%80%81%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">八、SwiftUI 生命周期问题、异步数据加载和状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81SwiftUI-%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99"><span class="toc-number">9.</span> <span class="toc-text">九、SwiftUI 编译报错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Struct-%E2%80%98YourViewName%E2%80%99-has-no-initializers"><span class="toc-number">9.1.</span> <span class="toc-text">1.Struct ‘YourViewName’ has no initializers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-No-exact-matches-in-reference-to-static-method-%E2%80%98buildExpression%E2%80%99"><span class="toc-number">9.2.</span> <span class="toc-text">2.No exact matches in reference to static method ‘buildExpression’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-swiftUI-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">3.swiftUI 传递参数问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-No-matching-navigationDestination-declaration"><span class="toc-number">9.4.</span> <span class="toc-text">4.No matching navigationDestination declaration&#96;</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/06/MCP-%E4%B8%8E-Vibe-Coding/" title="MCP 与 Vibe Coding">MCP 与 Vibe Coding</a><time datetime="2025-06-06T12:18:27.000Z" title="发表于 2025-06-06 20:18:27">2025-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/06/RN-%E4%B8%8D%E6%98%AF-Webview/" title="RN 不是 Webview">RN 不是 Webview</a><time datetime="2025-06-06T10:54:43.000Z" title="发表于 2025-06-06 18:54:43">2025-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/06/%E6%BC%82%E4%BA%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE/" title="漂亮的使用协议">漂亮的使用协议</a><time datetime="2025-06-06T10:06:15.000Z" title="发表于 2025-06-06 18:06:15">2025-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/07/SwiftUI%20%E5%AD%A6%E4%B9%A0/" title="SwiftUI 学习">SwiftUI 学习</a><time datetime="2025-05-07T10:05:15.000Z" title="发表于 2025-05-07 18:05:15">2025-05-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/07/Swift%20%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-Task%20%E5%92%8C%20async-await%20/" title="Swift 中的函数式编程以及 Task 和 async/await 的使用">Swift 中的函数式编程以及 Task 和 async/await 的使用</a><time datetime="2025-05-07T10:04:15.000Z" title="发表于 2025-05-07 18:04:15">2025-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 葛聪颖</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>